"use strict";(self.webpackChunkportfolio_app=self.webpackChunkportfolio_app||[]).push([[4352],{5102:function(e,n,t){t.r(n),t.d(n,{BlogPost:function(){return p},default:function(){return g}});var r=t(8453),i=t(6540);function l(e){const n=Object.assign({p:"p",h1:"h1",pre:"pre",code:"code"},(0,r.R)(),e.components);return i.createElement(i.Fragment,null,i.createElement(n.p,null,"Starting with a hard problem today."),"\n",i.createElement(n.h1,null,"Solution"),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-python"},"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        lenTotal = len(''.join(words))\n        perms = set()\n        def permutations(head, tail):\n            if not len(head):\n                perms.add(tail)\n            for i in range(len(head)):\n                permutations(head[:i] + head[i+1:], tail + head[i])\n        permutations(words, '')\n\n        result = []\n        for i in range(0, len(s)):\n            if s[i:i+lenTotal] in perms:\n                result.append(i)\n        \n        return result\n")),"\n",i.createElement(n.p,null,"This solution times out. It has a time complexity of O(n) = n! due to the permutations method."),"\n",i.createElement(n.p,null,"I'm going to try again using python's ",i.createElement(n.code,null,"itertools.permutations")," method. However, this lead to an out of memory error.\nRethinking the algorithm, we can remove the step where we find all permutations. Instead, we will replace our ",i.createElement(n.code,null,"perms")," set with a method called ",i.createElement(n.code,null,"validSubstring(substring)"),". This method will use a copy of the list of words, and we will loop through the substring and remove any word occurrences. If we always find a word at each step in our substring, we return True. We improve the efficiency of our algorithm by caching the result of each substring as either ",i.createElement(n.code,null,"validSubstring")," or ",i.createElement(n.code,null,"invalidSubstring")," set members. This solution is accepted."),"\n",i.createElement(n.pre,null,i.createElement(n.code,{className:"language-python"},"import itertools\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if len(s) < len(''.join(words)):\n            return []\n\n        wordLen = len(words[0])\n        def validSubstring(substring):\n            wordsTemp = words[:]\n            for i in range(0, len(substring), wordLen):\n                currWord = substring[i:i + wordLen]\n                if currWord in wordsTemp:\n                    wordsTemp.remove(currWord)\n                else:\n                    return False\n            return True\n        \n        invalidSubstrings = set()\n        validSubstrings = set()\n        wordsLen = wordLen * len(words)\n        window = s[:wordsLen]\n        res = []\n        if validSubstring(window):\n            validSubstrings.add(window)\n            res.append(0)\n\n        for i in range(wordsLen, len(s)):\n            letter = s[i]\n            window = window[1:]\n            window += letter\n            if window not in invalidSubstrings:\n                if window in validSubstrings or validSubstring(window):\n                    res.append(i - wordsLen + 1)\n                    validSubstrings.add(window)\n                else:\n                    invalidSubstrings.add(window)\n        \n        return res\n```\nThe time complexity is O(n) = n * k^2 where k is the number of words. It is k^2 because we loop through k words and the remove operation is O(k) = k. \n\n")))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.R)(),e.components);return n?i.createElement(n,e,i.createElement(l,e)):l(e)},s=t(4810),a=t(4399),d=t(3614),u=t(1510),m=t(6409),c=t(572);const p=u.default.div.withConfig({displayName:"blogPostTemplate__BlogPost",componentId:"sc-6bdelx-0"})(["margin:0 auto;margin-top:6em;max-width:800px;padding:20px;"]);function w(e){let{data:n,pageContext:t,children:r}=e;const{frontmatter:l}=n.mdx,{previous:o,next:w,post:g}=t;return i.createElement(a.A,null,i.createElement(u.ThemeProvider,{theme:d.w4},i.createElement(d.nB,null,i.createElement(m.A,null),i.createElement(p,null,i.createElement(d.DZ,{className:"text-center"},l.title),i.createElement("p",{className:"text-center"},g.frontmatter.date),r,o&&i.createElement(i.Fragment,null,o&&i.createElement(s.N_,{to:o.fields.slug},i.createElement("p",null,o.frontmatter.title))),w&&i.createElement(i.Fragment,null,w&&i.createElement(s.N_,{to:w.fields.slug},i.createElement("p",null,w.frontmatter.title)))),i.createElement(c.A,null))))}function g(e){return i.createElement(w,e,i.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-11-02-leetcode-30-index-mdx-18c61b795c12cebb639c.js.map