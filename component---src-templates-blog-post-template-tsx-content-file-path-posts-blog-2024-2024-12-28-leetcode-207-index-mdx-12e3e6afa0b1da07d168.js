"use strict";(self.webpackChunkportfolio_app=self.webpackChunkportfolio_app||[]).push([[8738],{9179:function(e,n,r){r.r(n),r.d(n,{BlogPost:function(){return m},default:function(){return h}});var t=r(8453),o=r(6540);function s(e){const n=Object.assign({p:"p",h1:"h1",pre:"pre",code:"code"},(0,t.R)(),e.components);return o.createElement(o.Fragment,null,o.createElement(n.p,null,"Today I worked on a general graph problem. My initial solution was much more verbose and less readable than\r\nanother coder's solution. However, I feel like during an interview I would have been able to derive\r\nthe simpler solution through asking questions, such as whether any course number will exceed the numCourses variable.\r\nI also need to be more mindful of what data I need to track or else I create unnecessary classes."),"\n",o.createElement(n.h1,null,"My Solution"),"\n",o.createElement(n.pre,null,o.createElement(n.code,{className:"language-python"},"class Node:\r\n    def __init__(self, val: int, toNodes: List['Node'] = None, fromNodes: List['Node'] = None):\r\n        self.val = val\r\n        self.toNodes = toNodes if toNodes is not None else []\r\n        self.fromNodes = fromNodes if fromNodes is not None else []\r\n\r\nclass Solution:\r\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\r\n        if not prerequisites:\r\n            return True\r\n\r\n        nodes = {}\r\n        for after, before in prerequisites:\r\n            if after not in nodes:\r\n                nodes[after] = Node(after)\r\n            afterNode = nodes[after]\r\n\r\n            if before not in nodes:\r\n                nodes[before] = Node(before)\r\n            beforeNode = nodes[before]\r\n            beforeNode.toNodes.append(afterNode)\r\n            afterNode.fromNodes.append(beforeNode)\r\n        \r\n        topological_order = []\r\n        stack = set()\r\n        visited = set()\r\n        has_cycle = False\r\n        def dfs(node):\r\n            nonlocal has_cycle\r\n            if node in stack:\r\n                return False\r\n            if node in visited:\r\n                return True\r\n            \r\n            stack.add(node)\r\n            print(node.val)\r\n            for child in node.toNodes:\r\n                if not dfs(child):\r\n                    has_cycle = True\r\n            stack.remove(node)\r\n            visited.add(node)\r\n            topological_order.append(node.val)\r\n            return True\r\n        \r\n        for node in nodes.values():\r\n            #if not node.fromNodes:\r\n            dfs(node)\r\n            if has_cycle:\r\n                return False\r\n\r\n        return len(topological_order) <= numCourses\n")),"\n",o.createElement(n.p,null,"The time complexity is O(M + N) where M are the number of nodes and N are the number of edges, as each are visited once. The space complexity is the same as it grows linearly with the input size.\r\nI used a class to build a directed graph which I could use to attempt a topological sort,\r\nthis sort would allow me to check if there are less courses than numCourses and also detect cycles.\r\nHowever, the problem states numCourses is always less than the course numbers, we could instead\r\ncheck each course if we may satisfy it's given prerequisites up to numCourses.\r\nBy default, we can say a course doesn't have any prerequisites. Therefor, we only\r\nneed to check if there is ever a cycle, which we can detect using a set that tracks\r\nwhich courses we've taken."),"\n",o.createElement(n.p,null,"If we can go through every course up to numCourses without visiting a taken class,\r\nwe can return true. The topological order is unnecessary, however, it is given that\r\na topological order exists if we can complete the courses."),"\n",o.createElement(n.h1,null,"Improved Solution"),"\n",o.createElement(n.pre,null,o.createElement(n.code,{className:"language-python"},"class Solution:\r\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\r\n        from collections import defaultdict\r\n\r\n        pres = defaultdict(list)\r\n        for course, pre in prerequisites:\r\n            pres[course].append(pre)\r\n        \r\n        taken = set()\r\n        def dfs(course):\r\n            if not pres[course]:\r\n                return True\r\n            \r\n            if course in taken:\r\n                return False # Cycle detected\r\n            \r\n            taken.add(course)\r\n            for pre in pres[course]:\r\n                if not dfs(pre):\r\n                    return False\r\n            \r\n            pres[course] = []\r\n            return True\r\n        \r\n        for course in range(numCourses):\r\n            if not dfs(course):\r\n                return False\r\n        \r\n        return True\n")))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.R)(),e.components);return n?o.createElement(n,e,o.createElement(s,e)):s(e)},l=r(4810),i=r(4399),c=r(3614),u=r(1510),d=r(6409),f=r(572);const m=u.default.div.withConfig({displayName:"blogPostTemplate__BlogPost",componentId:"sc-6bdelx-0"})(["margin:0 auto;margin-top:6em;max-width:800px;padding:20px;"]);function p(e){let{data:n,pageContext:r,children:t}=e;const{frontmatter:s}=n.mdx,{previous:a,next:p,post:h}=r;return o.createElement(i.A,null,o.createElement(u.ThemeProvider,{theme:c.w4},o.createElement(c.nB,null,o.createElement(d.A,null),o.createElement(m,null,o.createElement(c.DZ,{className:"text-center"},s.title),o.createElement("p",{className:"text-center"},h.frontmatter.date),t,a&&o.createElement(o.Fragment,null,a&&o.createElement(l.N_,{to:a.fields.slug},o.createElement("p",null,a.frontmatter.title))),p&&o.createElement(o.Fragment,null,p&&o.createElement(l.N_,{to:p.fields.slug},o.createElement("p",null,p.frontmatter.title)))),o.createElement(f.A,null))))}function h(e){return o.createElement(p,e,o.createElement(a,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-12-28-leetcode-207-index-mdx-12e3e6afa0b1da07d168.js.map