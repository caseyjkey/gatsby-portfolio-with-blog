"use strict";(self.webpackChunkportfolio_app=self.webpackChunkportfolio_app||[]).push([[2395],{4857:function(e,n,t){t.r(n),t.d(n,{BlogPost:function(){return d},default:function(){return h}});var r=t(8453),a=t(6540);function l(e){const n=Object.assign({p:"p",h1:"h1",pre:"pre",code:"code"},(0,r.R)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,"Here's another backtracking problem. For this post, I'd like to discuss the differences between\r\nmy solution and another submitted solution."),"\n",a.createElement(n.h1,null,"My Solution"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-python"},"class Solution:\r\n    def generateParenthesis(self, n: int) -> List[str]:\r\n        results = []\r\n        def backtrack(openP, closedP, curr):\r\n            if openP == n and closedP == n:\r\n                results.append(''.join(curr))\r\n                return\r\n            \r\n            if openP != n:\r\n                curr.append('(')\r\n                backtrack(openP + 1, closedP, curr)\r\n                curr.pop()\r\n\r\n            if closedP < openP:\r\n                curr.append(')')\r\n                backtrack(openP, closedP + 1, curr)\r\n                curr.pop()\r\n\r\n        backtrack(0, 0, [])\r\n        return results\n")),"\n",a.createElement(n.p,null,"The time complexity is O(2n * Catalan(n)) since for each solution (there are Catalan(n))  of the recursion stack, we work on N-i subproblems, where i is from 0 to k. The space complexity is O(k * n choose k) since each result requires k space."),"\n",a.createElement(n.h1,null,"niits' Solution"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-python"},'class Solution:\r\n    def generateParenthesis(self, n: int) -> List[str]:\r\n        res = []\r\n\r\n        def dfs(openP, closeP, s):\r\n            if openP == closeP and openP + closeP == n * 2:\r\n                res.append(s)\r\n                return\r\n            \r\n            if openP < n:\r\n                dfs(openP + 1, closeP, s + "(")\r\n            \r\n            if closeP < openP:\r\n                dfs(openP, closeP + 1, s + ")")\r\n\r\n        dfs(0, 0, "")\r\n\r\n        return res\n')),"\n",a.createElement(n.p,null,"The main differences I see are the base case and use of string concatanation.\r\nI believe there is marginal difference in time complexity for my equality checks\r\nand niits' addition plus multiplication equality. My solution is more readable.\r\nThe use of string concatanation by niits' is easier to read, but it uses more memory\r\nas each recursive call creates a new string while mine is passed between each recursive call.\r\nThe duplication of strings by recursive calls adds an average of 2n complexity to the\r\nexisting 2n complexity found in my solution."))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.R)(),e.components);return n?a.createElement(n,e,a.createElement(l,e)):l(e)},o=t(4810),c=t(4733),i=t(40),u=(t(5147),t(1686)),p=t(9389),m=t(9654);const d=u.default.div.withConfig({displayName:"blogPostTemplate__BlogPost",componentId:"sc-1p2ssye-0"})(["margin:0 auto;margin-top:6em;max-width:800px;padding:20px;"]);function f(e){let{data:n,pageContext:t,children:r}=e;const{frontmatter:l}=n.mdx,{previous:s,next:f,post:h}=t;return a.createElement(c.A,null,a.createElement(u.ThemeProvider,{theme:i.w4},a.createElement(i.nB,null,a.createElement(p.A),a.createElement(d,null,a.createElement(i.DZ,{className:"text-center"},l.title),a.createElement("p",{className:"text-center"},h.frontmatter.date),r,s&&a.createElement(a.Fragment,null,s&&a.createElement(o.N_,{to:s.fields.slug},a.createElement("p",null,s.frontmatter.title))),f&&a.createElement(a.Fragment,null,f&&a.createElement(o.N_,{to:f.fields.slug},a.createElement("p",null,f.frontmatter.title)))),a.createElement(m.A))))}function h(e){return a.createElement(f,e,a.createElement(s,e))}},5147:function(e,n,t){t(6540)}}]);
//# sourceMappingURL=component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-12-25-leetcode-22-index-mdx-c72a21d9304fd4299b84.js.map