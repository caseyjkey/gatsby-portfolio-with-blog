"use strict";(self.webpackChunkportfolio_app=self.webpackChunkportfolio_app||[]).push([[3651],{3841:function(e,n,t){t.r(n),t.d(n,{BlogPost:function(){return v},default:function(){return S}});var r=t(8453),i=t(6540);function o(e){const n=Object.assign({p:"p",hr:"hr",h1:"h1",pre:"pre",code:"code"},(0,r.R)(),e.components),{AnimatedSection:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("AnimatedSection",!0),i.createElement(i.Fragment,null,i.createElement(t,{index:"0"},i.createElement(n.p,null,"Starting with a hard problem today.")),"\n",i.createElement(n.hr),"\n",i.createElement(t,{index:"1"},i.createElement(n.h1,null,"Solution"),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-python"},"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        lenTotal = len(''.join(words))\n        perms = set()\n        def permutations(head, tail):\n            if not len(head):\n                perms.add(tail)\n            for i in range(len(head)):\n                permutations(head[:i] + head[i+1:], tail + head[i])\n        permutations(words, '')\n\n        result = []\n        for i in range(0, len(s)):\n            if s[i:i+lenTotal] in perms:\n                result.append(i)\n        \n        return result\n")),i.createElement(n.p,null,"This solution times out. It has a time complexity of O(n) = n! due to the permutations method."),i.createElement(n.p,null,"I'm going to try again using python's ",i.createElement(n.code,null,"itertools.permutations")," method. However, this lead to an out of memory error.\nRethinking the algorithm, we can remove the step where we find all permutations. Instead, we will replace our ",i.createElement(n.code,null,"perms")," set with a method called ",i.createElement(n.code,null,"validSubstring(substring)"),". This method will use a copy of the list of words, and we will loop through the substring and remove any word occurrences. If we always find a word at each step in our substring, we return True. We improve the efficiency of our algorithm by caching the result of each substring as either ",i.createElement(n.code,null,"validSubstring")," or ",i.createElement(n.code,null,"invalidSubstring")," set members. This solution is accepted."),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-python"},"import itertools\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if len(s) < len(''.join(words)):\n            return []\n\n        wordLen = len(words[0])\n        def validSubstring(substring):\n            wordsTemp = words[:]\n            for i in range(0, len(substring), wordLen):\n                currWord = substring[i:i + wordLen]\n                if currWord in wordsTemp:\n                    wordsTemp.remove(currWord)\n                else:\n                    return False\n            return True\n        \n        invalidSubstrings = set()\n        validSubstrings = set()\n        wordsLen = wordLen * len(words)\n        window = s[:wordsLen]\n        res = []\n        if validSubstring(window):\n            validSubstrings.add(window)\n            res.append(0)\n\n        for i in range(wordsLen, len(s)):\n            letter = s[i]\n            window = window[1:]\n            window += letter\n            if window not in invalidSubstrings:\n                if window in validSubstrings or validSubstring(window):\n                    res.append(i - wordsLen + 1)\n                    validSubstrings.add(window)\n                else:\n                    invalidSubstrings.add(window)\n        \n        return res\n```\nThe time complexity is O(n) = n * k^2 where k is the number of words. It is k^2 because we loop through k words and the remove operation is O(k) = k. \n\n"))))}var l=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.R)(),e.components);return n?i.createElement(n,e,i.createElement(o,e)):o(e)};var a=t(4810),s=t(4399),d=t(3614),c=t(3679),m=t(6115),u=t(5079),p=t(572),w=t(5169),h=t(2140),f=t(4253),g=t(6708),b=t(6118),E=t(3496);const v=c.Ay.div.withConfig({displayName:"blogPostTemplate__BlogPost",componentId:"sc-6bdelx-0"})(["margin-top:6em;padding-bottom:0.5rem;color:",";p,li{color:",";}.subheading{color:",";}"],e=>e.theme.black,e=>e.theme.black,e=>(0,m.a)(.6,e.theme.black));function y(e){let{data:n,pageContext:t,children:r}=e;const{frontmatter:o}=n.mdx,{previous:l,next:m,post:y}=t,{ref:S,isInView:k}=(0,b.G)({once:!0}),{ref:L,isInView:T}=(0,b.G)({once:!0}),{ref:x,isInView:N}=(0,b.G)({once:!0});return i.createElement(s.A,null,i.createElement(c.NP,{theme:d.w4},i.createElement(d.nB,null,i.createElement(u.A,null),i.createElement(w.A,{className:"mt-5"},i.createElement(v,null,i.createElement(h.P.div,{ref:S,initial:"hidden",animate:k?"visible":"hidden",custom:{delay:0,distance:g.BV.sectionHeader.distance},variants:f.HM,className:"mb-5"},i.createElement(d.DZ,{className:"text-center mb-4"},o.title)),i.createElement(h.P.p,{ref:L,initial:"hidden",animate:T?"visible":"hidden",custom:{delay:g.kU.default},variants:f.HM,className:"text-center subheading"},y.frontmatter.date),i.createElement(E.A,null,r),i.createElement(h.P.div,{ref:x,initial:"hidden",animate:N?"visible":"hidden",custom:{delay:0,distance:g.BV.primaryUnit.distance},variants:f.HM,className:"mt-5"},l&&i.createElement(a.N_,{to:l.fields.slug},i.createElement("p",null,"← ",l.frontmatter.title)),m&&i.createElement(a.N_,{to:m.fields.slug},i.createElement("p",null,m.frontmatter.title," →"))))),i.createElement(p.A,null))))}function S(e){return i.createElement(y,e,i.createElement(l,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-02-leetcode-30-index-mdx-8ea8d5239fc361718475.js.map