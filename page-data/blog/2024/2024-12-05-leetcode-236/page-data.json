{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-12-05-leetcode-236-index-mdx","path":"/blog/2024/2024-12-05-leetcode-236/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 236. Lowest Common Ancestor of a Binary Tree"}}},"pageContext":{"slug":"/blog/2024/2024-12-05-leetcode-236/","previous":{"fields":{"slug":"/blog/2024/2024-11-28-leetcode-105/"},"frontmatter":{"title":"LeetCode 105. Construct Binary Tree from Preoder and Inorder Traversal","date":"November 28, 2024"},"body":"\nHappy Thanksgiving! I am happy to have solved this without looking up a solution. However, I did have to review traversals.\n\n___\n\n# Solution\n```python\nfrom collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        top = deque(preorder)\n        bottom = deque(inorder)\n        nodes = []\n        seen = set()\n\n        root = parent = TreeNode()\n        while top:\n            parent.right = TreeNode(top.popleft())\n            left = parent.right\n            seen.add(left.val)\n            nodes.append(left)\n            while left.val != bottom[0]:\n                left.left = TreeNode(top.popleft())\n                left = left.left\n                seen.add(left.val)\n                nodes.append(left)\n            while bottom and bottom[0] in seen:\n                bottom.popleft()\n                parent = nodes.pop()\n            \n        return root.right\n```\nTime complexity is O(n) = n and space complexity is O(n) due to set and deques.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-28-leetcode-105/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-12-12-leetcode-103/"},"frontmatter":{"title":"LeetCode 103. Binary Tree Zigzag Level Order Traversal","date":"December 12, 2024"},"body":"\nI am glad I was able to make a solution from my own intuition.\n\n___\n\n# Solution\n```python\nfrom collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        nodes = deque([root] if root else [])\n        rightToLeft = False\n\n        result = []\n        while nodes:\n            level = []\n            children = deque([])\n            for i in range(len(nodes)):\n                if rightToLeft:\n                    node = nodes.pop()\n                    node.right and children.appendleft(node.right)\n                    node.left and children.appendleft(node.left)\n                else:\n                    node = nodes.popleft()\n                    node.left and children.append(node.left)\n                    node.right and children.append(node.right)\n                level.append(node.val)\n            result.append(level)\n            if rightToLeft:\n                nodes += children\n            else:\n                nodes = children + nodes\n            rightToLeft = not rightToLeft\n        return result\n```\nTime complexity is O(n) = n and space complexity is O(n).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-12-12-leetcode-103/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-12-05-leetcode-236/"},"frontmatter":{"title":"LeetCode 236. Lowest Common Ancestor of a Binary Tree","date":"December 5, 2024"},"body":"\nThis is the last month of my goal toward 150 problems done by 2025. I'll have to pick up more than a few problems this weekend. I have 56 problems remaining.\n\n___\n\n# Solution\n```python\nfrom collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if root in (None, p, q): return root\n        left, right = [self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)]\n        return root if left and right else left or right\n            \n\n```\nTime complexity is O(n) = n and space complexity is O(h) where the height is h. Best case the height is log(n) as a balanced tree and worst case is n as a skewed tree.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-12-05-leetcode-236/index.mdx"}},"frontmatter":{"title":"LeetCode 236. Lowest Common Ancestor of a Binary Tree","date":"2024-12-05T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}