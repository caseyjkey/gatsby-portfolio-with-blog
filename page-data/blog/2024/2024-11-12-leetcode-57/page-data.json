{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-12-leetcode-57-index-mdx","path":"/blog/2024/2024-11-12-leetcode-57/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 57. Insert Interval"}}},"pageContext":{"slug":"/blog/2024/2024-11-12-leetcode-57/","previous":{"fields":{"slug":"/blog/2024/2024-11-11-leetcode-56/"},"frontmatter":{"title":"LeetCode 56. Merge Intervals","date":"November 11, 2024"},"body":"\r\nNow I'm onto intervals. This one merges all intersecting intervals and returns the distinct items.\r\n\r\n# Solution\r\n```python\r\nclass Solution:\r\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\r\n        res = []\r\n        intervals = sorted(intervals)\r\n        start, end = intervals[0]\r\n        for item in intervals[1:]:\r\n            if end >= item[0] and item[1] > end:\r\n                end = item[1]\r\n            if start >= item[0] and start <= item[1]:\r\n                start = item[0]\r\n            if end < item[0] or start > item[1]:\r\n                res.append([start, end])\r\n                start, end = item\r\n        res.append([start, end])\r\n        return res\r\n```\r\nO(n) = nlog(n) due to the sorted() method\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-11-leetcode-56/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-11-13-leetcode-150/"},"frontmatter":{"title":"LeetCode 150. Evaluate Reverse Polish Notation","date":"November 13, 2024"},"body":"\r\nNow I'm on to stacks. I had to rethink my strategy of going from right to left, to left to right. I was overcomplicating it.\r\n\r\n# Solution\r\n```python\r\nclass Solution:\r\n    def evalRPN(self, tokens: List[str]) -> int:\r\n        stack = []\r\n        for token in tokens:\r\n            if token in ['+', '/', '+', '-', '*']:\r\n                right = int(stack.pop())\r\n                left = int(stack.pop())\r\n                match token:\r\n                    case '+':\r\n                        res = left + right\r\n                    case '/':\r\n                        res = left / right\r\n                    case '+':\r\n                        res = left + right\r\n                    case '-':\r\n                        res = left - right\r\n                    case '*':\r\n                        res = left * right\r\n                stack.append(res)\r\n            else:\r\n                stack.append(token)\r\n        return int(stack[-1])\r\n\r\n            \r\n```\r\nO(n) = n since we iterate over all elements once. Space complexity also O(n) = n for the stack.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-13-leetcode-150/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-11-12-leetcode-57/"},"frontmatter":{"title":"LeetCode 57. Insert Interval","date":"November 12, 2024"},"body":"\r\nThis took me a long time to cover all cases. \r\n\r\n# Solution\r\n```python\r\nclass Solution:\r\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\r\n        start, end = newInterval\r\n        inserted = False\r\n        res = []\r\n        for item in intervals:\r\n            if end < item[0]:\r\n                if not inserted:\r\n                    res.append([start, end])\r\n                    inserted = True\r\n                res.append(item)\r\n            elif end >= item[0] and end <= item[1]:\r\n                start = item[0] if item[0] < start else start\r\n                end = item[1]\r\n            elif start >= item[0] and end <= item[1]:\r\n                start, end = item\r\n                res.append([start, end])\r\n                inserted = True\r\n            elif start >= item[0] and start <= item[1] and end > item[1]:\r\n                start = item[0]\r\n            elif start > item[1]:\r\n                res.append(item)\r\n\r\n        if not inserted:\r\n            res.append([start, end])\r\n        return res\r\n            \r\n```\r\nO(n) = n since we iterate over all elements once.\r\n\r\n## Improvements\r\nThis solution has the same complexity, but it is simpler thereby being more maintanable.\r\n\r\n```python\r\nclass Solution:\r\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\r\n        res = []\r\n        n = len(intervals)\r\n\r\n        i = 0\r\n        while i < n and intervals[i][1] < newInterval[0]:\r\n            res.append(intervals[i])\r\n            i += 1\r\n\r\n        while i < n and newInterval[1] >= intervals[i][0]:\r\n            newInterval[0] = min(intervals[i][0], newInterval[0])\r\n            newInterval[1] = max(intervals[i][1], newInterval[1])\r\n            i += 1\r\n        \r\n        res.append(newInterval)\r\n        res.extend(intervals[i:])\r\n\r\n        return res\r\n```\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-12-leetcode-57/index.mdx"}},"frontmatter":{"title":"LeetCode 57. Insert Interval","date":"2024-11-12T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}