{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-19-leetcode-25-index-mdx","path":"/blog/2024/2024-11-19-leetcode-25/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 25. Reverse Nodes in k-Group"}}},"pageContext":{"slug":"/blog/2024/2024-11-19-leetcode-25/","previous":{"fields":{"slug":"/blog/2024/2024-11-18-leetcode-92/"},"frontmatter":{"title":"LeetCode 92. Reverse Linked List II","date":"November 18, 2024"},"body":"\r\nI was able to reduce this time complexity from  O(n) = 2n to O(n) = n by using a list for the elements to be reversed, and then only modifying those rather than stepping through all nodes while reversing.\r\n\r\n# Solution\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\r\n        first = head\r\n        start = None\r\n        end = None\r\n        last = None\r\n        toReverse = []\r\n        i = 0\r\n        while i < right:\r\n            if i == max(left - 2, 0):\r\n                start = head\r\n            if i == right - 1:\r\n                end = head\r\n            if i >= left - 1 and i < right - 1:\r\n                toReverse.append(head)\r\n            head = head.next\r\n            i += 1\r\n        \r\n        last = end.next\r\n        if left > 1:\r\n            start.next = end\r\n            start = start.next\r\n        else:\r\n            start = end\r\n            first = start\r\n        head = start\r\n        while toReverse:\r\n            head.next = toReverse.pop()\r\n            head = head.next\r\n        if head.next:\r\n            head.next = last\r\n\r\n        return first\r\n```\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-18-leetcode-92/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-11-20-leetcode-100/"},"frontmatter":{"title":"LeetCode 100. Same Tree","date":"November 20, 2024"},"body":"\r\nToday I chose an easy problem since I had a late day at work and gym afterwards.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        pQ = deque([p])\r\n        qQ = deque([q])\r\n\r\n        while pQ and qQ:\r\n            nodeP = pQ.popleft()\r\n            nodeQ = qQ.popleft()\r\n            if nodeP and nodeQ and nodeP.val != nodeQ.val:\r\n                return False\r\n            elif (nodeP is None) != (nodeQ is None):\r\n                return False\r\n\r\n            if nodeP:\r\n                pQ.append(nodeP.left)\r\n                pQ.append(nodeP.right)\r\n            if nodeQ:\r\n                qQ.append(nodeQ.left)\r\n                qQ.append(nodeQ.right)\r\n\r\n        if not pQ and not qQ:\r\n            return True\r\n        \r\n        return False\r\n```\r\nTime complexity is O(n) = n and space complexity is O(n).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-20-leetcode-100/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-11-19-leetcode-25/"},"frontmatter":{"title":"LeetCode 25. Reverse Nodes in k-Group","date":"November 19, 2024"},"body":"\r\nI had difficulties with this problem with terminating completed lists. I was surprised that ChatGPT didn't give this simple solution, \r\nit suggested a large rework. I'll have to be mindful before implementing all of ChatGPT's suggestions.\r\n\r\n# Solution\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        batch = []\r\n        start = None\r\n        curr = None\r\n        while head:\r\n            batch.append(head)\r\n            head = head.next\r\n            if len(batch) == k:\r\n                if curr:\r\n                    curr.next = batch.pop()\r\n                    curr = curr.next\r\n                else:\r\n                    curr = batch.pop()\r\n                    if not start:\r\n                        start = curr\r\n                     \r\n                while batch:\r\n                    curr.next = batch.pop()\r\n                    curr = curr.next\r\n                \r\n        if batch and curr:\r\n            curr.next = batch[0]\r\n        elif batch:\r\n            start = batch[0]\r\n        elif not batch and curr:\r\n            curr.next = None\r\n        \r\n        return start\r\n```\r\nTime complexity is O(n) = n and space complexity is O(k).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-19-leetcode-25/index.mdx"}},"frontmatter":{"title":"LeetCode 25. Reverse Nodes in k-Group","date":"2024-11-19T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}