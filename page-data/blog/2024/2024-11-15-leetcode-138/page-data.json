{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-15-leetcode-138-index-mdx","path":"/blog/2024/2024-11-15-leetcode-138/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 138. Copy List with Random Pointer"}}},"pageContext":{"slug":"/blog/2024/2024-11-15-leetcode-138/","previous":{"fields":{"slug":"/blog/2024/2024-11-14-leetcode-224/"},"frontmatter":{"title":"LeetCode 224. Basic Calculator","date":"November 14, 2024"},"body":"\nFinal stack problem for this practice set is a hard question. \nTook me an hour and a half to come up with this convoluted method. Parsing numbers character by character was my first mistake.\n\n___\n\n# Solution\n```python\nclass Solution:\n    def calculate(self, s: str) -> int:\n        parsed = []\n        num = ''\n        for token in s:\n            if token in ['(', ')', '+', '-', ' ']:\n                if num:\n                    parsed.append(num)\n                    num = ''\n                parsed.append(token)\n            else:\n                num += token\n        if num:\n            parsed.append(num)\n\n        s = parsed\n        nums = []\n        ops = []\n        total = 0\n        for token in s:\n            match token:\n                case '(':\n                    ops.append('(')\n                    nums.append('(')\n                case ')':\n                    ops.pop()\n                    right = nums.pop()\n                    nums.pop()\n                    if ops and ops[-1] != '(' and right != '(':\n                        op = ops.pop()\n                        if op == '+':\n                            total = nums.pop() + right\n                        elif op == '-':\n                            if nums and nums[-1] != '(':\n                                total = nums.pop() - right\n                            else:\n                                total = right * -1\n                        nums.append(total)\n                        total = 0\n                    else:\n                        nums.append(right)\n                case '-':\n                    ops.append('-')\n                case '+':\n                    ops.append('+')\n                case ' ':\n                    pass\n                case _:\n                    if not ops or ops[-1] == '(':\n                        total += int(token)\n                    else:\n                        op = ops.pop()\n                        if op == '+':\n                            total = int(token) + nums.pop()\n                        elif op == '-':\n                            if nums and nums[-1] != '(':\n                                total = int(nums.pop()) - int(token)\n                            else:\n                                total = -1 * int(token)\n                    nums.append(total)\n                    total = 0\n        return nums[-1]\n```\nO(n) = n since we iterate over all elements once. Space complexity also O(n) = n for the stack.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-14-leetcode-224/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-11-18-leetcode-92/"},"frontmatter":{"title":"LeetCode 92. Reverse Linked List II","date":"November 18, 2024"},"body":"\nI was able to reduce this time complexity from  O(n) = 2n to O(n) = n by using a list for the elements to be reversed, and then only modifying those rather than stepping through all nodes while reversing.\n\n___\n\n# Solution\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        first = head\n        start = None\n        end = None\n        last = None\n        toReverse = []\n        i = 0\n        while i < right:\n            if i == max(left - 2, 0):\n                start = head\n            if i == right - 1:\n                end = head\n            if i >= left - 1 and i < right - 1:\n                toReverse.append(head)\n            head = head.next\n            i += 1\n        \n        last = end.next\n        if left > 1:\n            start.next = end\n            start = start.next\n        else:\n            start = end\n            first = start\n        head = start\n        while toReverse:\n            head.next = toReverse.pop()\n            head = head.next\n        if head.next:\n            head.next = last\n\n        return first\n```\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-18-leetcode-92/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-11-15-leetcode-138/"},"frontmatter":{"title":"LeetCode 138. Copy List with Random Pointer","date":"November 15, 2024"},"body":"\nThis problem was tricky as I had to track Node references rather than the index given in the input.\n\n___\n\n# Solution\n```python\nfrom collections import defaultdict\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        start = Node(head.val) if head else None\n        node = start\n        randoms = defaultdict(list)\n        nodes = {}\n        while head:\n            nodes[head] = node\n            node.next = Node(head.next.val) if head.next else None\n            node.val = head.val\n            if head.random:\n                randoms[head.random].append(head)\n            head = head.next\n            node = node.next\n        \n        for val in randoms.keys():\n            for neighbor in randoms[val]:\n                nodes[neighbor].random = nodes[val]\n\n        return start\n```\nO(n) = n since worst case is 2n due to the while loop, then at most visiting each node again when assigning the randoms' value.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-15-leetcode-138/index.mdx"}},"frontmatter":{"title":"LeetCode 138. Copy List with Random Pointer","date":"2024-11-15T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}