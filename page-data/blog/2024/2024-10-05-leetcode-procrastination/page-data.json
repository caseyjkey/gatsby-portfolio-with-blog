{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-10-05-leetcode-procrastination-index-mdx","path":"/blog/2024/2024-10-05-leetcode-procrastination/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 191. Number of 1 Bits"}}},"pageContext":{"slug":"/blog/2024/2024-10-05-leetcode-procrastination/","previous":{"fields":{"slug":"/blog/2024/2024-10-04-second-leetcode/"},"frontmatter":{"title":"LeetCode 190. Reverse Bits","date":"October 4, 2024"},"body":"\n# 190. Reverse Bits\nToday is another easy problem, and it is focused on bit manipulation.\nLet's dive on in.\n\n___\n\n## The Problem\nToday's problem is **190. Reverse Bits**. The problem is as follows:\nReverse bits of a given 32 bits unsigned integer.\n\n___\n\n## The Solution\nI like to format my answers using the UMPIRE method:\n* Understand\n    * We are given a 32-bit unsigned integer, and we are to reverse the bits.\n* Match\n    * We can match this problem to a bit manipulation problem.\n* Plan\n    * We can write a function which casts the number to binary, then a string, and finally reverses it before casting back to binary.\n* Implement\n``` python\n    def reverseBits(self, n: int) -> int:\n        b = bin(n)\n        s = str(b)[2:].zfill(32)\n        s = s[::-1]\n        return int(s, 2) \n```\n* Review\n    * The code is clean and concise. We used descriptive variable names. We have implemented a bit manipulation.\n    * We can test our code using the examples provided.\n    * n = 43261596\n        * b = '0b10100101000001111010011100'\n        * s = '00000010100101000001111010011100'\n        * s = '00111001011110000010100101000000'\n``` python\n    def test_reverseBits(self):\n        assert self.reverseBits(43261596) == 964176192\n        assert self.reverseBits(4294967293) == 3221225471\n```\n* Evaluate\n    * Our code runs in O(n) time complexity due to our list slicing.\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-10-04-second-leetcode/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-10-06-another-leetcode/"},"frontmatter":{"title":"Another LeetCode Blog Post","date":"October 6, 2024"},"body":"\nWe're solving another LeetCode problem today. Tomorrow I will add my new project. Let's dive in.\n\n___\n\n## The Problem\nToday's problem is **9. Palindrome Number**. The problem is as follows:\nGiven an integer x, return true if x is a palindrome, and false otherwise.\n\nExample 1:\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\nExample 2:\n\nExample 2:\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Write a function that takes the binary representation of a positive integer and returns the number of \nset bits it has (also known as the Hamming weight).\n\n___\n\n## The Solution\nLet's answer using the UMPIRE method:\n* Understand\n    * We are given an integer, and we are to determine if it is a palindrome.\n    * In an interview. I would ask if we can solve this using strings or if I should solve it mathematically.\n* Match\n    * We can match this problem to a math problem or string problem. \n* Plan\n    * We can write a function which casts the number a string, and it will check if the first and last digits are the same until there is 1 or less digits.\n* Implement\n``` python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        def recursivePalindrome(s: str) -> bool:\n            if len(s) <= 1:\n                return True\n            elif s[0] != s[-1]:\n                return False\n            return recursivePalindrome(s[1:-1])\n        \n        return recursivePalindrome(str(x))\n```\n* Review\n    * We implemented this using a locally defined recursive function.\n    * We can test our code using the examples provided.\n    * x = 121\n        * return True\n``` python\n    def test_isPalindrome(self):\n        assert self.test_isPalindrome(1221)\n        assert not self.test_isPalindrome(31)\n```\n* Evaluate\n    * Our code runs in O(n) time complexity due the call being done n/2 times. \n    * Our space complexity is O(n) as we are storing the string in memory each time we recursively call.\n        * We can reduce the complexity to constant space by using pointers.\n\n``` python\n    def isPalindrome(x: int) -> bool:\n        s = str(x)\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n```","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-10-06-another-leetcode/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-10-05-leetcode-procrastination/"},"frontmatter":{"title":"LeetCode 191. Number of 1 Bits","date":"October 5, 2024"},"body":"\nWe're solving another LeetCode problem today instead of adding a new project to my portfolio. This one is focused on bit manipulation. Let's dive in.\n\n___\n\n## The Problem\nToday's problem is **191. Number of 1 Bits**. The problem is as follows:\nWrite a function that takes the binary representation of a positive integer and returns the number of \nset bits it has (also known as the Hamming weight).\n\n___\n\n## The Solution\nLet's answer using the UMPIRE method:\n* Understand\n    * We are given a positive integer, and we are to count the number of 1 bits of the number in bina.\n* Match\n    * We can match this problem to a bit manipulation problem or an array looping problem. \n* Plan\n    * We can write a function which casts the number to binary, then a string, and finally counts the number of 1's using a loop.\n* Implement\n``` python\n    def countBits(self, n: int) -> int:\n        b = bin(n)\n        s = str(b)[2:]\n        count = 0\n        for bit in s:\n            if bit == '1':\n                count += 1\n        return count\n```\n* Review\n    * The code is clean and concise. We used descriptive variable names.\n    * We can test our code using the examples provided.\n    * n = 4\n        * b = '0b0100'\n        * s = '0100'\n        * count = 1\n``` python\n    def test_reverseBits(self):\n        assert self.countBits(4) == 1\n        assert self.reverseBits(3) == 2\n```\n* Evaluate\n    * Our code runs in O(n) time complexity due to our loop through the string.\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-10-05-leetcode-procrastination/index.mdx"}},"frontmatter":{"title":"LeetCode 191. Number of 1 Bits","date":"2024-10-05T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}