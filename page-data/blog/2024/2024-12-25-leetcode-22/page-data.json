{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-12-25-leetcode-22-index-mdx","path":"/blog/2024/2024-12-25-leetcode-22/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 22. Generate Parentheses"}}},"pageContext":{"slug":"/blog/2024/2024-12-25-leetcode-22/","previous":{"fields":{"slug":"/blog/2024/2024-12-21-leetcode-77/"},"frontmatter":{"title":"LeetCode 77. Combinations","date":"December 21, 2024"},"body":"\nI've been working on backtracking problems. For this one, it helped to visualize the \nrecursion stack using [Python Tutor](https://pythontutor.com/visualize.html#mode=edit).\nAlso, I will have to revisit this later as the complexity analysis is out-of-the-ordinary.\n\n___\n\n# Solution\n```python\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        nums = [n for n in range(1, n + 1)]\n        results = []\n        def backtrack(nums, result):\n            if len(result) == k:\n                results.append(result[:])\n                return\n            \n            while nums:\n                backtrack(nums[1:], result + [nums.pop(0)])\n        \n        backtrack(nums, [])\n        return results\n```\nThe time complexity is O(N choose K) since for each frame of the recursion stack, we work on N-i subproblems, where i is from 0 to k. The space complexity is O(k * n choose k) since each result requires k space. \n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-12-21-leetcode-77/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-12-28-leetcode-207/"},"frontmatter":{"title":"LeetCode 207. Course Schedule","date":"December 28, 2024"},"body":"\nToday I worked on a general graph problem. My initial solution was much more verbose and less readable than\nanother coder's solution. However, I feel like during an interview I would have been able to derive\nthe simpler solution through asking questions, such as whether any course number will exceed the numCourses variable.\nI also need to be more mindful of what data I need to track or else I create unnecessary classes.\n\n___\n\n# My Solution\n```python\nclass Node:\n    def __init__(self, val: int, toNodes: List['Node'] = None, fromNodes: List['Node'] = None):\n        self.val = val\n        self.toNodes = toNodes if toNodes is not None else []\n        self.fromNodes = fromNodes if fromNodes is not None else []\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        if not prerequisites:\n            return True\n\n        nodes = {}\n        for after, before in prerequisites:\n            if after not in nodes:\n                nodes[after] = Node(after)\n            afterNode = nodes[after]\n\n            if before not in nodes:\n                nodes[before] = Node(before)\n            beforeNode = nodes[before]\n            beforeNode.toNodes.append(afterNode)\n            afterNode.fromNodes.append(beforeNode)\n        \n        topological_order = []\n        stack = set()\n        visited = set()\n        has_cycle = False\n        def dfs(node):\n            nonlocal has_cycle\n            if node in stack:\n                return False\n            if node in visited:\n                return True\n            \n            stack.add(node)\n            print(node.val)\n            for child in node.toNodes:\n                if not dfs(child):\n                    has_cycle = True\n            stack.remove(node)\n            visited.add(node)\n            topological_order.append(node.val)\n            return True\n        \n        for node in nodes.values():\n            #if not node.fromNodes:\n            dfs(node)\n            if has_cycle:\n                return False\n\n        return len(topological_order) <= numCourses\n```\nThe time complexity is O(M + N) where M are the number of nodes and N are the number of edges, as each are visited once. The space complexity is the same as it grows linearly with the input size.\nI used a class to build a directed graph which I could use to attempt a topological sort,\nthis sort would allow me to check if there are less courses than numCourses and also detect cycles.\nHowever, the problem states numCourses is always less than the course numbers, we could instead\ncheck each course if we may satisfy it's given prerequisites up to numCourses.\nBy default, we can say a course doesn't have any prerequisites. Therefor, we only\nneed to check if there is ever a cycle, which we can detect using a set that tracks \nwhich courses we've taken.\n\nIf we can go through every course up to numCourses without visiting a taken class,\nwe can return true. The topological order is unnecessary, however, it is given that \na topological order exists if we can complete the courses.\n\n___\n\n# Improved Solution\n```python\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        from collections import defaultdict\n\n        pres = defaultdict(list)\n        for course, pre in prerequisites:\n            pres[course].append(pre)\n        \n        taken = set()\n        def dfs(course):\n            if not pres[course]:\n                return True\n            \n            if course in taken:\n                return False # Cycle detected\n            \n            taken.add(course)\n            for pre in pres[course]:\n                if not dfs(pre):\n                    return False\n            \n            pres[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n        \n        return True\n```","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-12-28-leetcode-207/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-12-25-leetcode-22/"},"frontmatter":{"title":"LeetCode 22. Generate Parentheses","date":"December 25, 2024"},"body":"\nHere's another backtracking problem. For this post, I'd like to discuss the differences between\nmy solution and another submitted solution.\n\n___\n\n# My Solution\n```python\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        results = []\n        def backtrack(openP, closedP, curr):\n            if openP == n and closedP == n:\n                results.append(''.join(curr))\n                return\n            \n            if openP != n:\n                curr.append('(')\n                backtrack(openP + 1, closedP, curr)\n                curr.pop()\n\n            if closedP < openP:\n                curr.append(')')\n                backtrack(openP, closedP + 1, curr)\n                curr.pop()\n\n        backtrack(0, 0, [])\n        return results\n```\nThe time complexity is O(2n * Catalan(n)) since for each solution (there are Catalan(n))  of the recursion stack, we work on N-i subproblems, where i is from 0 to k. The space complexity is O(k * n choose k) since each result requires k space. \n\n___\n\n# niits' Solution\n```python\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []\n\n        def dfs(openP, closeP, s):\n            if openP == closeP and openP + closeP == n * 2:\n                res.append(s)\n                return\n            \n            if openP < n:\n                dfs(openP + 1, closeP, s + \"(\")\n            \n            if closeP < openP:\n                dfs(openP, closeP + 1, s + \")\")\n\n        dfs(0, 0, \"\")\n\n        return res\n```\nThe main differences I see are the base case and use of string concatanation.\nI believe there is marginal difference in time complexity for my equality checks\nand niits' addition plus multiplication equality. My solution is more readable.\nThe use of string concatanation by niits' is easier to read, but it uses more memory\nas each recursive call creates a new string while mine is passed between each recursive call.\nThe duplication of strings by recursive calls adds an average of 2n complexity to the \nexisting 2n complexity found in my solution.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-12-25-leetcode-22/index.mdx"}},"frontmatter":{"title":"LeetCode 22. Generate Parentheses","date":"2024-12-25T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}