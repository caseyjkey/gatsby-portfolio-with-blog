{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-20-leetcode-100-index-mdx","path":"/blog/2024/2024-11-20-leetcode-100/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 100. Same Tree"}}},"pageContext":{"slug":"/blog/2024/2024-11-20-leetcode-100/","previous":{"fields":{"slug":"/blog/2024/2024-11-19-leetcode-25/"},"frontmatter":{"title":"LeetCode 25. Reverse Nodes in k-Group","date":"November 19, 2024"},"body":"\nI had difficulties with this problem with terminating completed lists. I was surprised that ChatGPT didn't give this simple solution, \nit suggested a large rework. I'll have to be mindful before implementing all of ChatGPT's suggestions.\n\n___\n\n# Solution\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        batch = []\n        start = None\n        curr = None\n        while head:\n            batch.append(head)\n            head = head.next\n            if len(batch) == k:\n                if curr:\n                    curr.next = batch.pop()\n                    curr = curr.next\n                else:\n                    curr = batch.pop()\n                    if not start:\n                        start = curr\n                     \n                while batch:\n                    curr.next = batch.pop()\n                    curr = curr.next\n                \n        if batch and curr:\n            curr.next = batch[0]\n        elif batch:\n            start = batch[0]\n        elif not batch and curr:\n            curr.next = None\n        \n        return start\n```\nTime complexity is O(n) = n and space complexity is O(k).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-19-leetcode-25/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-11-21-leetcode-82/"},"frontmatter":{"title":"LeetCode 82. Remove Duplicates from Sorted List II","date":"November 21, 2024"},"body":"\nThe trick for this one was tracking duplicates via the unique boolean and a pending variable.\n\n___\n\n# Solution\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        start = None\n        curr = None\n        pending = None\n        unique = True\n        while head:\n            if not pending:\n                pending = head\n            elif pending.val != head.val and unique:\n                if not start:\n                    start = pending\n                    curr = start\n                else:\n                    curr.next = pending\n                    curr = curr.next\n                pending = head\n            elif pending.val != head.val and not unique:\n                pending = head\n                unique = True\n            else:\n                unique = False\n                if curr:\n                    curr.next = None\n            head = head.next\n        \n        if pending and unique:\n            if start:\n                curr.next = pending\n            else:\n                start = pending\n\n        return start\n```\nTime complexity is O(n) = n and space complexity is O(1).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-21-leetcode-82/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-11-20-leetcode-100/"},"frontmatter":{"title":"LeetCode 100. Same Tree","date":"November 20, 2024"},"body":"\nToday I chose an easy problem since I had a late day at work and gym afterwards.\n\n___\n\n# Solution\n```python\nfrom collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        pQ = deque([p])\n        qQ = deque([q])\n\n        while pQ and qQ:\n            nodeP = pQ.popleft()\n            nodeQ = qQ.popleft()\n            if nodeP and nodeQ and nodeP.val != nodeQ.val:\n                return False\n            elif (nodeP is None) != (nodeQ is None):\n                return False\n\n            if nodeP:\n                pQ.append(nodeP.left)\n                pQ.append(nodeP.right)\n            if nodeQ:\n                qQ.append(nodeQ.left)\n                qQ.append(nodeQ.right)\n\n        if not pQ and not qQ:\n            return True\n        \n        return False\n```\nTime complexity is O(n) = n and space complexity is O(n).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-20-leetcode-100/index.mdx"}},"frontmatter":{"title":"LeetCode 100. Same Tree","date":"2024-11-20T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}