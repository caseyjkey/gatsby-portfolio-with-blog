{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-13-leetcode-150-index-mdx","path":"/blog/2024/2024-11-13-leetcode-150/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 150. Evaluate Reverse Polish Notation"}}},"pageContext":{"slug":"/blog/2024/2024-11-13-leetcode-150/","previous":{"fields":{"slug":"/blog/2024/2024-11-12-leetcode-57/"},"frontmatter":{"title":"LeetCode 57. Insert Interval","date":"November 12, 2024"},"body":"\nThis took me a long time to cover all cases. \n\n___\n\n# Solution\n```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        inserted = False\n        res = []\n        for item in intervals:\n            if end < item[0]:\n                if not inserted:\n                    res.append([start, end])\n                    inserted = True\n                res.append(item)\n            elif end >= item[0] and end <= item[1]:\n                start = item[0] if item[0] < start else start\n                end = item[1]\n            elif start >= item[0] and end <= item[1]:\n                start, end = item\n                res.append([start, end])\n                inserted = True\n            elif start >= item[0] and start <= item[1] and end > item[1]:\n                start = item[0]\n            elif start > item[1]:\n                res.append(item)\n\n        if not inserted:\n            res.append([start, end])\n        return res\n            \n```\nO(n) = n since we iterate over all elements once.\n\n___\n\n## Improvements\nThis solution has the same complexity, but it is simpler thereby being more maintanable.\n\n```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n        n = len(intervals)\n\n        i = 0\n        while i < n and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n\n        while i < n and newInterval[1] >= intervals[i][0]:\n            newInterval[0] = min(intervals[i][0], newInterval[0])\n            newInterval[1] = max(intervals[i][1], newInterval[1])\n            i += 1\n        \n        res.append(newInterval)\n        res.extend(intervals[i:])\n\n        return res\n```\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-12-leetcode-57/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-11-14-leetcode-224/"},"frontmatter":{"title":"LeetCode 224. Basic Calculator","date":"November 14, 2024"},"body":"\nFinal stack problem for this practice set is a hard question. \nTook me an hour and a half to come up with this convoluted method. Parsing numbers character by character was my first mistake.\n\n___\n\n# Solution\n```python\nclass Solution:\n    def calculate(self, s: str) -> int:\n        parsed = []\n        num = ''\n        for token in s:\n            if token in ['(', ')', '+', '-', ' ']:\n                if num:\n                    parsed.append(num)\n                    num = ''\n                parsed.append(token)\n            else:\n                num += token\n        if num:\n            parsed.append(num)\n\n        s = parsed\n        nums = []\n        ops = []\n        total = 0\n        for token in s:\n            match token:\n                case '(':\n                    ops.append('(')\n                    nums.append('(')\n                case ')':\n                    ops.pop()\n                    right = nums.pop()\n                    nums.pop()\n                    if ops and ops[-1] != '(' and right != '(':\n                        op = ops.pop()\n                        if op == '+':\n                            total = nums.pop() + right\n                        elif op == '-':\n                            if nums and nums[-1] != '(':\n                                total = nums.pop() - right\n                            else:\n                                total = right * -1\n                        nums.append(total)\n                        total = 0\n                    else:\n                        nums.append(right)\n                case '-':\n                    ops.append('-')\n                case '+':\n                    ops.append('+')\n                case ' ':\n                    pass\n                case _:\n                    if not ops or ops[-1] == '(':\n                        total += int(token)\n                    else:\n                        op = ops.pop()\n                        if op == '+':\n                            total = int(token) + nums.pop()\n                        elif op == '-':\n                            if nums and nums[-1] != '(':\n                                total = int(nums.pop()) - int(token)\n                            else:\n                                total = -1 * int(token)\n                    nums.append(total)\n                    total = 0\n        return nums[-1]\n```\nO(n) = n since we iterate over all elements once. Space complexity also O(n) = n for the stack.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-14-leetcode-224/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-11-13-leetcode-150/"},"frontmatter":{"title":"LeetCode 150. Evaluate Reverse Polish Notation","date":"November 13, 2024"},"body":"\nNow I'm on to stacks. I had to rethink my strategy of going from right to left, to left to right. I was overcomplicating it.\n\n___\n\n# Solution\n```python\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            if token in ['+', '/', '+', '-', '*']:\n                right = int(stack.pop())\n                left = int(stack.pop())\n                match token:\n                    case '+':\n                        res = left + right\n                    case '/':\n                        res = left / right\n                    case '+':\n                        res = left + right\n                    case '-':\n                        res = left - right\n                    case '*':\n                        res = left * right\n                stack.append(res)\n            else:\n                stack.append(token)\n        return int(stack[-1])\n\n            \n```\nO(n) = n since we iterate over all elements once. Space complexity also O(n) = n for the stack.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-13-leetcode-150/index.mdx"}},"frontmatter":{"title":"LeetCode 150. Evaluate Reverse Polish Notation","date":"2024-11-13T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}