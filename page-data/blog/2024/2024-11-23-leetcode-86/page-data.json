{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-11-23-leetcode-86-index-mdx","path":"/blog/2024/2024-11-23-leetcode-86/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 86. Partition List"}}},"pageContext":{"slug":"/blog/2024/2024-11-23-leetcode-86/","previous":{"fields":{"slug":"/blog/2024/2024-11-21-leetcode-82/"},"frontmatter":{"title":"LeetCode 82. Remove Duplicates from Sorted List II","date":"November 21, 2024"},"body":"\nThe trick for this one was tracking duplicates via the unique boolean and a pending variable.\n\n___\n\n# Solution\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        start = None\n        curr = None\n        pending = None\n        unique = True\n        while head:\n            if not pending:\n                pending = head\n            elif pending.val != head.val and unique:\n                if not start:\n                    start = pending\n                    curr = start\n                else:\n                    curr.next = pending\n                    curr = curr.next\n                pending = head\n            elif pending.val != head.val and not unique:\n                pending = head\n                unique = True\n            else:\n                unique = False\n                if curr:\n                    curr.next = None\n            head = head.next\n        \n        if pending and unique:\n            if start:\n                curr.next = pending\n            else:\n                start = pending\n\n        return start\n```\nTime complexity is O(n) = n and space complexity is O(1).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-21-leetcode-82/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-11-26-leetcode-146/"},"frontmatter":{"title":"LeetCode 146. LRU Cache","date":"November 26, 2024"},"body":"\nThis took me a few days although it's only a medium! It is important to remember Python is pass-by-reference.\nI spent a lot of time debugging because I didn't mirror changes between previous and next nodes when moving a node between them.\nI was able to debug by creating a list of key-value pairs then printing the list after each operation.\n\n\n___\n\n# Solution\n```python\nclass Node:\n    def __init__(self, key=0, val=0, prev=None, next=None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.size = 0\n        self.d = {}\n        self.l = None\n        self.start = None\n\n    def get(self, key: int) -> int:\n        if key in self.d:\n            node = self.d[key]\n            if node.prev and node.next:\n                node.prev.next = node.next\n                node.next.prev = node.prev\n            elif node.next:\n                self.start = node.next\n                self.start.prev = None\n            if self.l != node:\n                node.prev = self.l\n                self.l.next = node\n                self.l = self.l.next\n                self.l.next = None\n            return node.val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if not key in self.d:\n            if self.size == self.capacity:\n                node = self.start\n                del self.d[node.key]\n                self.start = node.next\n                if self.start:\n                    self.start.prev = None\n                self.size -= 1\n            if self.l:\n                self.l.next = Node(key, value, self.l)\n                self.l = self.l.next\n            if not self.start:\n                self.start = Node(key, value)\n                self.l = self.start\n            self.d[key] = self.l\n            self.size += 1\n        else:\n            node = self.d[key]\n            if node == self.start and self.start.next:\n                self.start = self.start.next\n                self.start.prev = None\n            if node.prev and node.next:\n                node.prev.next = node.next\n                node.next.prev = node.prev\n            if node != self.l:\n                node.prev = self.l\n                self.l.next = node\n            node.val = value\n            node.next = None\n            self.l = node\n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\nTime complexity for get and put operations are O(n) = 1 and space complexity is O(n) due to the dictionary holding each element.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-26-leetcode-146/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-11-23-leetcode-86/"},"frontmatter":{"title":"LeetCode 86. Partition List","date":"November 23, 2024"},"body":"\nI had to read the comments to understand this problem. I didn't understand how they wanted the ordering until I read a few examples.\n\n___\n\n# Solution\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        start = head\n        left, right = None, None\n\n        while head and not right:\n            if head.val < x:\n                left = head\n            else:\n                right = head\n            head = head.next\n        \n        prev = None\n        \n        while head:\n            if head.val < x:\n                if prev:\n                    prev.next = head.next\n                if left:\n                    left.next = head\n                    left = left.next\n                else:\n                    left = head\n                    start = left\n                if right.next == head:\n                    right.next = head.next\n                head.next = right\n\n            prev = head\n            head = head.next\n        \n        return start\n```\nTime complexity is O(n) = n and space complexity is O(1).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-11-23-leetcode-86/index.mdx"}},"frontmatter":{"title":"LeetCode 86. Partition List","date":"2024-11-23T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}