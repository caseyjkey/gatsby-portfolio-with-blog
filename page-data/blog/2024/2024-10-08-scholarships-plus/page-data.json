{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2024-2024-10-08-scholarships-plus-index-mdx","path":"/blog/2024/2024-10-08-scholarships-plus/","result":{"data":{"mdx":{"frontmatter":{"title":"Scholarships Plus"}}},"pageContext":{"slug":"/blog/2024/2024-10-08-scholarships-plus/","previous":{"fields":{"slug":"/blog/2024/2024-10-07-intro-to-cursor/"},"frontmatter":{"title":"Intro to Cursor","date":"October 7, 2024"},"body":"\nToday I decided to embrace the AI revolution and try out Cursor. I'm going to write a quick LeetCode solution, then dive into some project ideas.\n\n___\n\n# LeetCode Problem\n\n___\n\n## The Problem\nSince we have some help from Cursor tonight, we wil be solving a hard problem.\nToday's problem is **4. Median of Two Sorted Arrays**. The problem is as follows:\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\nExample 1:\n    Input: nums1 = [1,3], nums2 = [2]\n    Output: 2.00000\n    Explanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n    Input: nums1 = [1,2], nums2 = [3,4]\n    Output: 2.50000\n    Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n___\n\n## The Solution\nLet's answer using the UMPIRE method:\n* Understand\n    * We have two sorted arrays, and we must merge them and find the median.\n    * The median is the middle value of a sorted list. If the list has an even number of elements, the median is the average of the two middle elements.\n* Match\n    * We can merge the two arrays and then find the median, but this would not be O(log(m+n)).\n    * We can use a modified binary search to find the median.\n        * Binary search is O(log n) and we can use it to find the median.\n* Plan\n    * We can use a modified binary search to find the median.\n    * We will use two pointers to traverse the arrays.\n    * We will use a helper function to find the median of the two arrays.\n* Implement\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        total_length = m + n\n        half = (total_length + 1) // 2\n        \n        left, right = 0, m\n        \n        while left <= right:\n            partition1 = (left + right) // 2\n            partition2 = half - partition1\n            \n            left1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')\n            right1 = nums1[partition1] if partition1 < m else float('inf')\n            left2 = nums2[partition2 - 1] if partition2 > 0 else float('-inf')\n            right2 = nums2[partition2] if partition2 < n else float('inf')\n            \n            if left1 <= right2 and left2 <= right1:\n                # We have found the correct partition\n                if total_length % 2 == 0:\n                    return (max(left1, left2) + min(right1, right2)) / 2\n                else:\n                    return max(left1, left2)\n            elif left1 > right2:\n                right = partition1 - 1\n            else:\n                left = partition1 + 1\n        \n        raise ValueError(\"Input arrays are not sorted\")\n\n```\n* Review\n    * The code is clean, it uses descriptive variables and follows a logical flow.\n    * The code is correct, it passes the test cases.\n* Evaluate\n    * The code is efficient, it runs in O(log(m+n)) time.\n    * We never iterate over the entire array, even in the worst case.\n\n___\n\n## Notes\nCursor generates duplicate responses. I had to remove unnecessary text.\nIt does not appear to elaborate on its reasoning.\nElaborating on specific parts is easy using the annotated keyboard commands.\nUsing cursor to write LeetCode solutions is great, but it won't be useful for interviews.\nHopefully it will be as useful for projects.\nIt would be nice if I could tab through the suggestions, rather than using tab to accept current suggestion.\nCursor has been a drop-in replacement for Code, requiring no configuration to continue prior development workflow.\n\n___\n\n# Project Ideas\nI had a few ideas for projects I want to build.\n* A wallpaper web app that scrapes image boards.\n    * It would have authentication for user accounts.\n        * Users can favorite wallpapers, saving them for later.\n        * Users can download wallpapers, saving bandwidth compared to anonymous access.\n    * It would hide NSFW wallpapers by parsing post text.\n* A scholarship essay assistant.\n    * It would use RAG to import past essays as context during prompts.\n    * It would use GPT-4o to proofread and improve essays.\n    * It would track scholarship deadlines.\n    * It would save essays to a user's Google Drive.\n\nI will use the wallpaper app to learn Next.js and Tailwind.\nI don't expect to spend much time on it, as it can only be monetized through ads.\nI will use the scholarship essay assistant to learn about:\n    * RAG,\n    * GPT-4o,\n    * Google Drive API,\n    * Docker,\n    * AWS,\n    * React,\n    * and TypeScript.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-10-07-intro-to-cursor/index.mdx"}},"next":{"fields":{"slug":"/blog/2024/2024-10-13-email-processing-design/"},"frontmatter":{"title":"Email Processing System Design","date":"October 13, 2024"},"body":"\nI'm looking forward to an interview for a software engineer position at StubHub.\nIt offers work with microservices, kubernetes, and cloud-native technologies.\nThe position focuses on DevOps, such as infrastructure, build, deployment, and artifact management.\nI'm excited because my current experience aligns with the position's focus. \nThis will be an improvement for my career as it offers better compensation and location (Santa Monica!).\n\n___\n\n# Interview Prep\nI checked Glassdoor, and it sounds like the technical interview question will be easier than Google was.\nIt will likely be a LeetCode medium or easy question, but there was mention of a system design question.\nSeveral people said they were asked to design an email processing system.\nSo, I want to write about how I would design such a system.\n\n___\n\n# System Design\n\n___\n\n## System Components\n\n___\n\n### Email Receiving\nEmails will be received through an API provided by the email hosting service.\nThe API will have a `/send` endpoint that the email provider can call to send an email to a user.\nThe API will have a `/receive` endpoint that the email provider can call to receive an email at a specific address.\n\n___\n\n### Email Parsing\nOnce an email is received, it needs to be parsed.\nThe content and metadata needs to be extracted.\nThe content needs to be converted to a format that can be processed by the system.\nThis would likely be a JSON blog format to be stored in a database.\n\n___\n\n### Email Classification\nEmails need to be categorized, at the least by their sender and receiver.\nThis will allow for the user and administrator to view their sent and received emails.\n\n___\n\n### Email Routing\nEmails need to be routed to the correct user.\nThis will allow for the user to view their emails.\nThis will be done by using their email address to look up the user ID in the database..\nThen, the email's content which was stored earlier will have its ID added to the user's received emails.\nThis could be stored as a one-to-many relationship.\n\n___\n\n### Email Storage\nEmails need to be stored in a database.\nThe database will need to be able to store the email's content, metadata, and tags.\nSince this data is structured, it is a good fit for a structured SQL database like Postgres.\n\n___\n\n### Email Client\nEmails can be exposed to the user in their client.\nTo do this, the data must be exposed through an API.\nThis will follow an email protocol such as SMTP, POP, or IMAP.\nWe follow the common protocols so the the user can use any email client to access their emails.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-10-13-email-processing-design/index.mdx"}},"post":{"fields":{"slug":"/blog/2024/2024-10-08-scholarships-plus/"},"frontmatter":{"title":"Scholarships Plus","date":"October 8, 2024"},"body":"\nI've began a new project, scholarships-plus. This will be a CRUD app for tracking and improving scholarship essays.\n\n___\n\n# App Idea\nI am creating this app to improve student's scholarship essays by improving their past submissions.\nThis app will allow students to upload their essays, and then use AI to improve them.\nI want to implement RAG to give context to essay prompts. \n\n___\n\n# Framework Choice\n\n___\n\n## Next.js vs Remix\nAt first, I wanted to use Next.js as my React framework since I used it while working with Amazon.\nHowever, I noticed that Next.js is more popular for its server-side rendering features.\nSince this will be a client-side app, I decided improved SEO through SSR is not needed for this app.\nSo, I decided to look into Remix. It looks great for building fast web apps with a focus on developer experience.\nI'm glad to have found a [great starter project](https://remix.run/resources/remix-blues-stack) integrating Postgres for the database, Cypress for testing, and a full CI/CD workflow through Github Actions.\nHowever, I feel like I am losing experience from setting all these features up from scratch. Hopefully the benefits of each component become apparent once I begin implementing my scholarship app.\n\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-10-08-scholarships-plus/index.mdx"}},"frontmatter":{"title":"Scholarships Plus","date":"2024-10-08T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}