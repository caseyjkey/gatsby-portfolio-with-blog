{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2025-2025-5-3-leetcode-32-index-mdx","path":"/blog/2025/2025-5-3-leetcode-32/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 32. Longest Valid Parantheses"}}},"pageContext":{"slug":"/blog/2025/2025-5-3-leetcode-32/","previous":{"fields":{"slug":"/blog/2025/2025-2-15-leetcode-1004/"},"frontmatter":{"title":"LeetCode 1004. Max Consecutive Ones III","date":"February 13, 2025"},"body":"\r\nI completed the LeetCode 150! Since then, I haven't stopped practicing.\r\nI want to master common algorithms and feel confident for future interviews.\r\n\r\nFor this problem, I started with this greedy solution. We always flip a zero if \r\nwe haven't done so `k` times. Each step, we check if our count is a new maximum.\r\nIf we reach a zero and used all our flips, we reset our count and flips.\r\nWe start counting again from this position.\r\n\r\n```python\r\nclass Solution:\r\n    def longestOnes(self, nums: List[int], k: int) -> int:\r\n        largest = float('-inf')\r\n        count = 0\r\n        flipped = 0\r\n        for num in nums:\r\n            if num == 1:\r\n                count += 1\r\n            if num == 0 and flipped < k:\r\n                count += 1\r\n                flipped += 1\r\n            elif num == 0 and flipped == k:\r\n                largest = max(largest, count)\r\n                count, flipped = 1, 1\r\n        \r\n        return largest\r\n```\r\nThis works for the first example:\r\n\r\n> Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\r\n>> Output: 6 (correct!)\r\n\r\nHowever, for the second example, it  fails to connect the first\r\ntwo strings of ones.\r\n\r\n> Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\r\n>> Output: 9 (incorrect, expected 10.)\r\n\r\nTo fix this, we will have to alter our algorithm to \r\nconditionally flip a zero. My idea is to apply our previous algorithm at each step.\r\n```python\r\nclass Solution:\r\n    def longestOnes(self, nums: List[int], k: int) -> int:\r\n        largest = float('-inf')\r\n\r\n        def countOnes(start):\r\n            count = 0\r\n            flipped = 0\r\n            for i in range(start, len(nums)):\r\n                num = nums[i]\r\n                if num == 1:\r\n                    count += 1\r\n                if num == 0 and flipped < k:\r\n                    choice = i \r\n                    count += 1\r\n                    flipped += 1\r\n                elif num == 0 and flipped == k:\r\n                    return count\r\n            return count\r\n        \r\n        for i in range(len(nums)):\r\n            largest = max(largest, countOnes(i))\r\n        \r\n        return largest\r\n```\r\nUnfortunately, this is inefficient, but it works. It has a quadratic time complexity of\r\nO(n) = (N^2 + n) / 2, also known as the nth triangle number.\r\n\r\nRather we should make this algorithm into a sliding-window algorithm.\r\nWhen we reach the end of a series of ones, we want to slide our window by moving our start to the\r\nsecond flip we made by removing our first flip along with any tail attached to it.\r\nTo do this, we create a queue and add our tail each time we flip and set the new tail to 0.\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def longestOnes(self, nums: List[int], k: int) -> int:\r\n        largest = float('-inf')\r\n        count, tail = 0, 0\r\n        tails = deque([])\r\n        for i, num in enumerate(nums):\r\n            count += 1\r\n            tail += 1\r\n            if num == 0:\r\n                if tails and len(tails) == k:\r\n                    count -= tails.popleft()\r\n                elif not k:\r\n                    count = 0\r\n                tails.append(tail)\r\n                tail = 0\r\n            largest = max(largest, count)\r\n        return largest\r\n```\r\nThis has a time complexity of O(n) = n at the tradeoff of space complexity being\r\nO(n) = n compared to O(n) = 1 for previous solutions.\r\n\r\n\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2025/2025-2-15-leetcode-1004/index.mdx"}},"next":{"fields":{"slug":"/projects/2024-04-farmx/"},"frontmatter":{"title":"Oracle Release Management","date":"October 1, 2025"},"body":"\n**Applications Developer 2** | April 2024 - September 2025\n\n## Key Achievements\n\n- Built and launched a scalable release management tool supporting 13,780 users with high reliability\n- Mentored new developers, facilitating knowledge transfer and collaborative problem-solving\n- Led onboarding and support for users, resolving bugs, gathering feedback, and refining key features\n- Efficiently ingested data sources with Python, DRF, and Celery for asynchronous data processing\n\n## Technologies Used\n\n- Git & GitLab\n- Python\n- JavaScript\n- Django & Django REST Framework\n- Oracle Database\n- Celery\n\n## Impact\n\nThis release management tool has become a critical piece of infrastructure, supporting thousands of users and streamlining the release process across the organization.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/projects/2024-04-farmx/index.mdx"}},"post":{"fields":{"slug":"/blog/2025/2025-5-3-leetcode-32/"},"frontmatter":{"title":"LeetCode 32. Longest Valid Parantheses","date":"May 3, 2025"},"body":"\r\nI went through a period of intense study, focusing on solving problems with C++.\r\nNow, I'm back to Python and happy to walk through this solution to\r\nlongest valid parantheses.\r\n\r\n```python\r\nclass Solution:\r\n    def longestValidParentheses(self, s: str) -> int:\r\n        stack = [-1]\r\n        max_len = 0\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == '(':\r\n                stack.append(i)\r\n            else:\r\n                stack.pop()\r\n                if not stack:\r\n                    stack.append(i)\r\n                else:\r\n                    max_len = max(max_len, i - stack[-1])\r\n        \r\n        return max_len\r\n```\r\nEach time we encounter an opening paranthesis, we add its index to our stack.\r\nThus, when we find a closing parenthesis, we pop the stack.\r\nThis will leave us with the index of the last invalid index, or an empty array (we reached an invalid closing paranthesis).\r\nWith that index of the last invalid paranthesis, we calculate the max length.\r\nThis works for this  example:\r\n\r\n> Input: s = \")()\"\r\n>> Output: 2 (correct!)\r\n\r\nWe can check with a longer example too.\r\n\r\n> Input: s = \")()()\"\r\n>> Output: 4\r\n\r\nThe time complexity is O(n) since we step through the array once,\r\nand our space complexity is also O(n).\r\nWe use a stack that can be up to N elements (all opening parantheses).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2025/2025-5-3-leetcode-32/index.mdx"}},"frontmatter":{"title":"LeetCode 32. Longest Valid Parantheses","date":"2025-05-03T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}