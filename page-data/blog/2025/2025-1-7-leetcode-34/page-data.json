{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2025-2025-1-7-leetcode-34-index-mdx","path":"/blog/2025/2025-1-7-leetcode-34/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 34. Find First and Last Position of Element in Sorted Array"}}},"pageContext":{"slug":"/blog/2025/2025-1-7-leetcode-34/","previous":{"fields":{"slug":"/blog/2024/2024-12-28-leetcode-207/"},"frontmatter":{"title":"LeetCode 207. Course Schedule","date":"December 28, 2024"},"body":"\nToday I worked on a general graph problem. My initial solution was much more verbose and less readable than\nanother coder's solution. However, I feel like during an interview I would have been able to derive\nthe simpler solution through asking questions, such as whether any course number will exceed the numCourses variable.\nI also need to be more mindful of what data I need to track or else I create unnecessary classes.\n\n___\n\n# My Solution\n```python\nclass Node:\n    def __init__(self, val: int, toNodes: List['Node'] = None, fromNodes: List['Node'] = None):\n        self.val = val\n        self.toNodes = toNodes if toNodes is not None else []\n        self.fromNodes = fromNodes if fromNodes is not None else []\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        if not prerequisites:\n            return True\n\n        nodes = {}\n        for after, before in prerequisites:\n            if after not in nodes:\n                nodes[after] = Node(after)\n            afterNode = nodes[after]\n\n            if before not in nodes:\n                nodes[before] = Node(before)\n            beforeNode = nodes[before]\n            beforeNode.toNodes.append(afterNode)\n            afterNode.fromNodes.append(beforeNode)\n        \n        topological_order = []\n        stack = set()\n        visited = set()\n        has_cycle = False\n        def dfs(node):\n            nonlocal has_cycle\n            if node in stack:\n                return False\n            if node in visited:\n                return True\n            \n            stack.add(node)\n            print(node.val)\n            for child in node.toNodes:\n                if not dfs(child):\n                    has_cycle = True\n            stack.remove(node)\n            visited.add(node)\n            topological_order.append(node.val)\n            return True\n        \n        for node in nodes.values():\n            #if not node.fromNodes:\n            dfs(node)\n            if has_cycle:\n                return False\n\n        return len(topological_order) <= numCourses\n```\nThe time complexity is O(M + N) where M are the number of nodes and N are the number of edges, as each are visited once. The space complexity is the same as it grows linearly with the input size.\nI used a class to build a directed graph which I could use to attempt a topological sort,\nthis sort would allow me to check if there are less courses than numCourses and also detect cycles.\nHowever, the problem states numCourses is always less than the course numbers, we could instead\ncheck each course if we may satisfy it's given prerequisites up to numCourses.\nBy default, we can say a course doesn't have any prerequisites. Therefor, we only\nneed to check if there is ever a cycle, which we can detect using a set that tracks \nwhich courses we've taken.\n\nIf we can go through every course up to numCourses without visiting a taken class,\nwe can return true. The topological order is unnecessary, however, it is given that \na topological order exists if we can complete the courses.\n\n___\n\n# Improved Solution\n```python\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        from collections import defaultdict\n\n        pres = defaultdict(list)\n        for course, pre in prerequisites:\n            pres[course].append(pre)\n        \n        taken = set()\n        def dfs(course):\n            if not pres[course]:\n                return True\n            \n            if course in taken:\n                return False # Cycle detected\n            \n            taken.add(course)\n            for pre in pres[course]:\n                if not dfs(pre):\n                    return False\n            \n            pres[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n        \n        return True\n```","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2024/2024-12-28-leetcode-207/index.mdx"}},"next":{"fields":{"slug":"/blog/2025/2025-1-21-leetcode-120/"},"frontmatter":{"title":"LeetCode 120. Triangle","date":"January 21, 2025"},"body":"\nToday I start working on multidimensional DP. I expect these problems to require a dynamicly-sized array\nto build a solution, rather than a static number of variables.\nI chose to write about this problem because it is a great example\nof how we can think of a problem from the bottom up to build an optimal solution.\n\n___\n\n# Initial Solution\n```python\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        rows = len(triangle)\n        memo = triangle[-1][:]\n        for row in range(rows - 2, -1, -1):\n            for col in range(row + 1):\n                memo[col] = min(memo[col], memo[col + 1]) + triangle[row][col]\n        return memo[0]\n```\nTime complexity is O(n) and space complexity is O(n).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2025/2025-1-21-leetcode-120/index.mdx"}},"post":{"fields":{"slug":"/blog/2025/2025-1-7-leetcode-34/"},"frontmatter":{"title":"LeetCode 34. Find First and Last Position of Element in Sorted Array","date":"January 7, 2025"},"body":"\nWe're working through binary search problems.\nThis one has an initial solution with many lines duplicated.\nWe further work the solution to use a function and a boolean variable to make the code more clean via the DRY principle.\n\n___\n\n# Initial Solution\n```python\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        start, end = 0, len(nums) - 1\n        result = [-1, -1]\n        while start <= end:\n            mid = start + (end - start) // 2\n            left = nums[mid - 1] if mid > 0 else float('-inf')\n            if nums[mid] == target:\n                if left != target:\n                    result[0] = mid\n                    break\n                end = mid - 1\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = start + (end - start) // 2\n            right = nums[mid + 1] if mid < len(nums) - 1 else float('inf')\n            if nums[mid] == target:\n                if right != target:\n                    result[1] = mid\n                    break\n                start = mid + 1\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return result\n```\nTime complexity is O(logn) and space complexity is O(1).\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/blog/2025/2025-1-7-leetcode-34/index.mdx"}},"frontmatter":{"title":"LeetCode 34. Find First and Last Position of Element in Sorted Array","date":"2025-01-07T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}