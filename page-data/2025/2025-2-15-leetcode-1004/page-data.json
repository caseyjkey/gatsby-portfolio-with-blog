{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2025-2025-2-15-leetcode-1004-index-mdx","path":"/2025/2025-2-15-leetcode-1004/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 1004. Max Consecutive Ones III"}}},"pageContext":{"slug":"/2025/2025-2-15-leetcode-1004/","previous":{"fields":{"slug":"/2025/2025-1-21-leetcode-120/"},"frontmatter":{"title":"LeetCode 120. Triangle","date":"January 21, 2025"},"body":"\r\nToday I start working on multidimensional DP. I expect these problems to require a dynamicly-sized array\r\nto build a solution, rather than a static number of variables.\r\nI chose to write about this problem because it is a great example\r\nof how we can think of a problem from the bottom up to build an optimal solution.\r\n\r\n# Initial Solution\r\n```python\r\nclass Solution:\r\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\r\n        rows = len(triangle)\r\n        memo = triangle[-1][:]\r\n        for row in range(rows - 2, -1, -1):\r\n            for col in range(row + 1):\r\n                memo[col] = min(memo[col], memo[col + 1]) + triangle[row][col]\r\n        return memo[0]\r\n```\r\nTime complexity is O(n) and space complexity is O(n).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2025/2025-1-21-leetcode-120/index.mdx"}},"next":null,"post":{"fields":{"slug":"/2025/2025-2-15-leetcode-1004/"},"frontmatter":{"title":"LeetCode 1004. Max Consecutive Ones III","date":"February 13, 2025"},"body":"\r\nI completed the LeetCode 150! Since then, I haven't stopped practicing.\r\nI want to master common algorithms and feel confident for future interviews.\r\n\r\nFor this problem, I started with this greedy solution. We always flip a zero if \r\nwe haven't done so `k` times. Each step, we check if our count is a new maximum.\r\nIf we reach a zero and used all our flips, we reset our count and flips.\r\nWe start counting again from this position.\r\n\r\n```python\r\nclass Solution:\r\n    def longestOnes(self, nums: List[int], k: int) -> int:\r\n        largest = float('-inf')\r\n        count = 0\r\n        flipped = 0\r\n        for num in nums:\r\n            if num == 1:\r\n                count += 1\r\n            if num == 0 and flipped < k:\r\n                count += 1\r\n                flipped += 1\r\n            elif num == 0 and flipped == k:\r\n                largest = max(largest, count)\r\n                count, flipped = 1, 1\r\n        \r\n        return largest\r\n```\r\nThis works for the first example:\r\n\"\"\"\r\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\r\nOutput: 6 (correct!)\r\n\"\"\"\r\nHowever, for the second example, it  fails to connect the first\r\ntwo strings of ones.\r\n\"\"\"\r\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\r\nOutput: 9 (incorrect, expected 10.)\r\n\"\"\"\r\nTo fix this, we will have to alter our algorithm to \r\nconditionally flip a zero. My idea is to apply our previous algorithm at each step.\r\n```python\r\nclass Solution:\r\n    def longestOnes(self, nums: List[int], k: int) -> int:\r\n        largest = float('-inf')\r\n\r\n        def countOnes(start):\r\n            count = 0\r\n            flipped = 0\r\n            for i in range(start, len(nums)):\r\n                num = nums[i]\r\n                if num == 1:\r\n                    count += 1\r\n                if num == 0 and flipped < k:\r\n                    choice = i \r\n                    count += 1\r\n                    flipped += 1\r\n                elif num == 0 and flipped == k:\r\n                    return count\r\n            return count\r\n        \r\n        for i in range(len(nums)):\r\n            largest = max(largest, countOnes(i))\r\n        \r\n        return largest\r\n```\r\nUnfortunately, this is inefficient, but it works. It has a quadratic time complexity of\r\nO(n) = (N^2 + n) / 2, also known as the nth triangle number.\r\n\r\nRather we should make this algorithm into a sliding-window algorithm.\r\nWhen we reach the end of a series of ones, we want to slide our window by moving our start to the\r\nsecond flip we made by removing our first flip along with any tail attached to it.\r\nTo do this, we create a queue and add our tail each time we flip and set the new tail to 0.\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def longestOnes(self, nums: List[int], k: int) -> int:\r\n        largest = float('-inf')\r\n        count, tail = 0, 0\r\n        tails = deque([])\r\n        for i, num in enumerate(nums):\r\n            count += 1\r\n            tail += 1\r\n            if num == 0:\r\n                if tails and len(tails) == k:\r\n                    count -= tails.popleft()\r\n                elif not k:\r\n                    count = 0\r\n                tails.append(tail)\r\n                tail = 0\r\n            largest = max(largest, count)\r\n        return largest\r\n```\r\nThis has a time complexity of O(n) = n at the tradeoff of space complexity being\r\nO(n) = n compared to O(n) = 1 for previous solutions.\r\n\r\n\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2025/2025-2-15-leetcode-1004/index.mdx"}},"frontmatter":{"title":"LeetCode 1004. Max Consecutive Ones III","date":"2025-02-13T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}