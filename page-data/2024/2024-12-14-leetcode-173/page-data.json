{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-12-14-leetcode-173-index-mdx","path":"/2024/2024-12-14-leetcode-173/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 173. Binary Search Tree Iterator"}}},"pageContext":{"slug":"/2024/2024-12-14-leetcode-173/","previous":{"fields":{"slug":"/2024/2024-12-12-leetcode-103/"},"frontmatter":{"title":"LeetCode 103. Binary Tree Zigzag Level Order Traversal","date":"December 12, 2024"},"body":"\r\nI am glad I was able to make a solution from my own intuition.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        nodes = deque([root] if root else [])\r\n        rightToLeft = False\r\n\r\n        result = []\r\n        while nodes:\r\n            level = []\r\n            children = deque([])\r\n            for i in range(len(nodes)):\r\n                if rightToLeft:\r\n                    node = nodes.pop()\r\n                    node.right and children.appendleft(node.right)\r\n                    node.left and children.appendleft(node.left)\r\n                else:\r\n                    node = nodes.popleft()\r\n                    node.left and children.append(node.left)\r\n                    node.right and children.append(node.right)\r\n                level.append(node.val)\r\n            result.append(level)\r\n            if rightToLeft:\r\n                nodes += children\r\n            else:\r\n                nodes = children + nodes\r\n            rightToLeft = not rightToLeft\r\n        return result\r\n```\r\nTime complexity is O(n) = n and space complexity is O(n).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-12-leetcode-103/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-12-18-leetcode-133/"},"frontmatter":{"title":"LeetCode 133. Clone Graph","date":"December 18, 2024"},"body":"\r\nThis problem stumped me for a while because I needed to use a dictionary to make sure I didn't have duplicate copies, then I also forgot to return the copy at the end of the DFS algorithm.\r\n\r\n# Solution\r\n```python\r\n\"\"\"\r\n# Definition for a Node.\r\nclass Node:\r\n    def __init__(self, val = 0, neighbors = None):\r\n        self.val = val\r\n        self.neighbors = neighbors if neighbors is not None else []\r\n\"\"\"\r\nfrom typing import Optional\r\nclass Solution:\r\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\r\n        if not node:\r\n            return None\r\n\r\n        copies = {}\r\n\r\n        def dfs(node):\r\n            if node in copies:\r\n                return copies[node]\r\n            \r\n            copy = Node(node.val)\r\n            copies[node] = copy\r\n            for n in node.neighbors:\r\n                copy.neighbors.append(dfs(n))\r\n            \r\n            return copy\r\n        \r\n        dfs(node)\r\n\r\n        return copies[node]\r\n```\r\nThe time complexity is O(V + E) since we visit every node and edge once, and then the space complexity is O(V) because our copies dictionary is always the number of verticies in the graph. The recursive call stack is also at worst case O(V) space complexity.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-18-leetcode-133/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-12-14-leetcode-173/"},"frontmatter":{"title":"LeetCode 173. Binary Search Tree Iterator","date":"December 14, 2024"},"body":"\r\nHere are two solutions. One is recursive and the other iterative.\r\nThe iterative solution is better as it can handle larger inputs.\r\n\r\n# Solution\r\nRecursive\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass BSTIterator:\r\n\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.nodes = deque([])\r\n\r\n        def traverse(node):\r\n            if not node:\r\n                return\r\n            \r\n            traverse(node.left)\r\n            self.nodes.append(node.val)\r\n            traverse(node.right)\r\n        \r\n        traverse(root)\r\n        \r\n\r\n    def next(self) -> int:\r\n        return self.nodes.popleft()\r\n\r\n    def hasNext(self) -> bool:\r\n        return len(self.nodes) > 0\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n```\r\nTime complexity is O(n) = n and space complexity is O(h).\r\n\r\niterative\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass BSTIterator:\r\n\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.nodes = []\r\n        self.pushAll(root)      \r\n\r\n    def next(self) -> int:\r\n        node = self.nodes.pop()\r\n        self.pushAll(node.right)\r\n        return node.val\r\n\r\n    def hasNext(self) -> bool:\r\n        return len(self.nodes) > 0\r\n    \r\n    def pushAll(self, node):\r\n        while node:\r\n            self.nodes.append(node)\r\n            node = node.left\r\n\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n```\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-14-leetcode-173/index.mdx"}},"frontmatter":{"title":"LeetCode 173. Binary Search Tree Iterator","date":"2024-12-14T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}