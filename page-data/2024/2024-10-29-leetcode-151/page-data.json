{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-10-29-leetcode-151-index-mdx","path":"/2024/2024-10-29-leetcode-151/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 12. Integer to Roman"}}},"pageContext":{"slug":"/2024/2024-10-29-leetcode-151/","previous":{"fields":{"slug":"/2024/2024-10-22-leetcode-74/"},"frontmatter":{"title":"LeetCode 74. Search a 2D Matrix","date":"October 22, 2024"},"body":"\nGetting back into the habit of solving LeetCode problems.\n\nToday's problem is [LeetCode 74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/).\n\nWe have to solve this in O(log(m*n)) time complexity.\nSo, I think of binary search in 2 dimensions. Once for the row, and once for the column.\n\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-22-leetcode-74/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-10-28-leetcode-12/"},"frontmatter":{"title":"LeetCode 12. Integer to Roman","date":"October 28, 2024"},"body":"\nI started feeling down about my past interview performance. Rather than continue ruminating, I decided to continue my\nLeetCode grind tonight. My goal is to complete the Top 150 Interview Questions before the end of the year.\n\n# Solution\n```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        digitCount = int((math.log10(num) + 1) // 1)\n        def getLeftmostDigit():\n            return num // (10 ** (digitCount - 1)) % 10\n        romanForm = \"\"\n        if digitCount == 4:\n            digit = getLeftmostDigit()\n            for i in range(digit): romanForm += \"M\" \n            digitCount -= 1\n        if digitCount == 3:\n            digit = getLeftmostDigit()\n            if digit in [4, 9]:\n                romanForm += \"CD\" if digit == 4 else \"CM\"\n                digit -= digit\n            elif digit >= 5:\n                romanForm += \"D\"\n                digit -= 5\n            for i in range(digit): romanForm += \"C\" \n            digitCount -= 1\n        if digitCount == 2:\n            digit = getLeftmostDigit()\n            if digit in [4, 9]:\n                romanForm += \"XL\" if digit == 4 else \"XC\"\n                digit -= digit\n            elif digit >= 5:\n                romanForm += \"L\"\n                digit -= 5\n            for i in range(digit): romanForm += \"X\"\n            digitCount -= 1\n        if digitCount == 1:\n            digit = getLeftmostDigit()\n            if digit in [4, 9]:\n                romanForm += \"IV\" if digit == 4 else \"IX\"\n                digit -= digit\n            elif digit >= 5:\n                romanForm += \"V\"\n                digit -= 5\n            for i in range(digit): romanForm += \"I\" \n\n        return romanForm\n```\nO(n) = 1\n\n## Reflection\nNext time, I would like to reduce the code complexity by abstracting the strings into a dictionary.\nWith the dictionary, I could loop for `digitCount` iterations and select the appropriate value from the dictionary.\nThis would remove the repeated code, thereby making it easier to read and maintain.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-28-leetcode-12/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-10-29-leetcode-151/"},"frontmatter":{"title":"LeetCode 12. Integer to Roman","date":"October 28, 2024"},"body":"\nFinished a couple easy problems, then this medium problem. I feel like this was made easier by python's list slicing.\n\n# Solution\n```python\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return ' '.join(s.split()[::-1])\n```\nO(n) = n\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-29-leetcode-151/index.mdx"}},"frontmatter":{"title":"LeetCode 12. Integer to Roman","date":"2024-10-28T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}