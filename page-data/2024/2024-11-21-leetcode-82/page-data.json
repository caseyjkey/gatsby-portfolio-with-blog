{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-11-21-leetcode-82-index-mdx","path":"/2024/2024-11-21-leetcode-82/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 82. Remove Duplicates from Sorted List II"}}},"pageContext":{"slug":"/2024/2024-11-21-leetcode-82/","previous":{"fields":{"slug":"/2024/2024-11-20-leetcode-100/"},"frontmatter":{"title":"LeetCode 100. Same Tree","date":"November 20, 2024"},"body":"\r\nToday I chose an easy problem since I had a late day at work and gym afterwards.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        pQ = deque([p])\r\n        qQ = deque([q])\r\n\r\n        while pQ and qQ:\r\n            nodeP = pQ.popleft()\r\n            nodeQ = qQ.popleft()\r\n            if nodeP and nodeQ and nodeP.val != nodeQ.val:\r\n                return False\r\n            elif (nodeP is None) != (nodeQ is None):\r\n                return False\r\n\r\n            if nodeP:\r\n                pQ.append(nodeP.left)\r\n                pQ.append(nodeP.right)\r\n            if nodeQ:\r\n                qQ.append(nodeQ.left)\r\n                qQ.append(nodeQ.right)\r\n\r\n        if not pQ and not qQ:\r\n            return True\r\n        \r\n        return False\r\n```\r\nTime complexity is O(n) = n and space complexity is O(n).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-20-leetcode-100/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-11-23-leetcode-86/"},"frontmatter":{"title":"LeetCode 86. Partition List","date":"November 23, 2024"},"body":"\r\nI had to read the comments to understand this problem. I didn't understand how they wanted the ordering until I read a few examples.\r\n\r\n# Solution\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\r\n        start = head\r\n        left, right = None, None\r\n\r\n        while head and not right:\r\n            if head.val < x:\r\n                left = head\r\n            else:\r\n                right = head\r\n            head = head.next\r\n        \r\n        prev = None\r\n        \r\n        while head:\r\n            if head.val < x:\r\n                if prev:\r\n                    prev.next = head.next\r\n                if left:\r\n                    left.next = head\r\n                    left = left.next\r\n                else:\r\n                    left = head\r\n                    start = left\r\n                if right.next == head:\r\n                    right.next = head.next\r\n                head.next = right\r\n\r\n            prev = head\r\n            head = head.next\r\n        \r\n        return start\r\n```\r\nTime complexity is O(n) = n and space complexity is O(1).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-23-leetcode-86/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-11-21-leetcode-82/"},"frontmatter":{"title":"LeetCode 82. Remove Duplicates from Sorted List II","date":"November 21, 2024"},"body":"\r\nThe trick for this one was tracking duplicates via the unique boolean and a pending variable.\r\n\r\n# Solution\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        start = None\r\n        curr = None\r\n        pending = None\r\n        unique = True\r\n        while head:\r\n            if not pending:\r\n                pending = head\r\n            elif pending.val != head.val and unique:\r\n                if not start:\r\n                    start = pending\r\n                    curr = start\r\n                else:\r\n                    curr.next = pending\r\n                    curr = curr.next\r\n                pending = head\r\n            elif pending.val != head.val and not unique:\r\n                pending = head\r\n                unique = True\r\n            else:\r\n                unique = False\r\n                if curr:\r\n                    curr.next = None\r\n            head = head.next\r\n        \r\n        if pending and unique:\r\n            if start:\r\n                curr.next = pending\r\n            else:\r\n                start = pending\r\n\r\n        return start\r\n```\r\nTime complexity is O(n) = n and space complexity is O(1).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-21-leetcode-82/index.mdx"}},"frontmatter":{"title":"LeetCode 82. Remove Duplicates from Sorted List II","date":"2024-11-21T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}