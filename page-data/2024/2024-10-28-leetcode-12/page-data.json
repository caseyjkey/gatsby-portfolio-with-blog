{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-10-28-leetcode-12-index-mdx","path":"/2024/2024-10-28-leetcode-12/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 12. Integer to Roman"}}},"pageContext":{"slug":"/2024/2024-10-28-leetcode-12/","previous":{"fields":{"slug":"/2024/2024-10-22-leetcode-74/"},"frontmatter":{"title":"LeetCode 74. Search a 2D Matrix","date":"October 22, 2024"},"body":"\nGetting back into the habit of solving LeetCode problems.\n\nToday's problem is [LeetCode 74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/).\n\nWe have to solve this in O(log(m*n)) time complexity.\nSo, I think of binary search in 2 dimensions. Once for the row, and once for the column.\n\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-22-leetcode-74/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-10-30-leetcode-6/"},"frontmatter":{"title":"LeetCode 6. Zigzag Conversion","date":"October 30, 2024"},"body":"\nThis one took me about 15 minutes to come up with a solution. I then worked through it with this naive solution.\n\n# Solution\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        grid = [['' for column in range(len(s))] for row in range(numRows)]\n        x, y = 0, 0\n        direction = 1\n        for char in s:\n            grid[y][x] = char\n            if y == numRows - 1:\n                direction = -1\n                x += 1\n            elif direction == -1 and y > 0:\n                x += 1\n            elif direction == -1 and y == 0:\n                direction = 1\n            y += direction if numRows > 1 else 0\n        result = \"\"\n        for row in grid:\n            for char in row:\n                if char:\n                    result += char\n        return result\n```\nO(n) = n*m or n^2\n\n## Reflection\nLooking back, I realized I didn't need to include the empty spaces as if it were illustrated. This allows me to simplify my code by using the append() method for lists. Here is my improved version:\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        grid = [[] for _ in range(numRows)]\n        y = 0 \n        direction = 1\n        for char in s:\n            grid[y].append(char)\n            if y == numRows - 1:\n                direction = -1\n            elif y == 0:\n                direction = 1\n            y += direction\n        \n        for i in range(len(grid)):\n            grid[i] = ''.join(grid[i])\n        result = ''.join(grid)\n        return result\n```\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-30-leetcode-6/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-10-28-leetcode-12/"},"frontmatter":{"title":"LeetCode 12. Integer to Roman","date":"October 28, 2024"},"body":"\nI started feeling down about my past interview performance. Rather than continue ruminating, I decided to continue my\nLeetCode grind tonight. My goal is to complete the Top 150 Interview Questions before the end of the year.\n\n# Solution\n```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        digitCount = int((math.log10(num) + 1) // 1)\n        def getLeftmostDigit():\n            return num // (10 ** (digitCount - 1)) % 10\n        romanForm = \"\"\n        if digitCount == 4:\n            digit = getLeftmostDigit()\n            for i in range(digit): romanForm += \"M\" \n            digitCount -= 1\n        if digitCount == 3:\n            digit = getLeftmostDigit()\n            if digit in [4, 9]:\n                romanForm += \"CD\" if digit == 4 else \"CM\"\n                digit -= digit\n            elif digit >= 5:\n                romanForm += \"D\"\n                digit -= 5\n            for i in range(digit): romanForm += \"C\" \n            digitCount -= 1\n        if digitCount == 2:\n            digit = getLeftmostDigit()\n            if digit in [4, 9]:\n                romanForm += \"XL\" if digit == 4 else \"XC\"\n                digit -= digit\n            elif digit >= 5:\n                romanForm += \"L\"\n                digit -= 5\n            for i in range(digit): romanForm += \"X\"\n            digitCount -= 1\n        if digitCount == 1:\n            digit = getLeftmostDigit()\n            if digit in [4, 9]:\n                romanForm += \"IV\" if digit == 4 else \"IX\"\n                digit -= digit\n            elif digit >= 5:\n                romanForm += \"V\"\n                digit -= 5\n            for i in range(digit): romanForm += \"I\" \n\n        return romanForm\n```\nO(n) = 1\n\n## Reflection\nNext time, I would like to reduce the code complexity by abstracting the strings into a dictionary.\nWith the dictionary, I could loop for `digitCount` iterations and select the appropriate value from the dictionary.\nThis would remove the repeated code, thereby making it easier to read and maintain.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-28-leetcode-12/index.mdx"}},"frontmatter":{"title":"LeetCode 12. Integer to Roman","date":"2024-10-28T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}