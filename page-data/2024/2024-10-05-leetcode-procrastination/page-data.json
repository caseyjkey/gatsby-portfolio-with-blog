{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-10-05-leetcode-procrastination-index-mdx","path":"/2024/2024-10-05-leetcode-procrastination/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode as Procrastination"}}},"pageContext":{"slug":"/2024/2024-10-05-leetcode-procrastination/","previous":{"fields":{"slug":"/2024/2024-10-04-second-leetcode/"},"frontmatter":{"title":"Second LeetCode Blog Post","date":"October 4, 2024"},"body":"\r\n# Second LeetCode Blog Post\r\nToday is another easy problem, and it is focused on bit manipulation.\r\nLet's dive on in.\r\n## The Problem\r\nToday's problem is **190. Reverse Bits**. The problem is as follows:\r\nReverse bits of a given 32 bits unsigned integer.\r\n\r\n## The Solution\r\nI like to format my answers using the UMPIRE method:\r\n* Understand\r\n    * We are given a 32-bit unsigned integer, and we are to reverse the bits.\r\n* Match\r\n    * We can match this problem to a bit manipulation problem.\r\n* Plan\r\n    * We can write a function which casts the number to binary, then a string, and finally reverses it before casting back to binary.\r\n* Implement\r\n``` python\r\n    def reverseBits(self, n: int) -> int:\r\n        b = bin(n)\r\n        s = str(b)[2:].zfill(32)\r\n        s = s[::-1]\r\n        return int(s, 2) \r\n```\r\n* Review\r\n    * The code is clean and concise. We used descriptive variable names. We have implemented a bit manipulation.\r\n    * We can test our code using the examples provided.\r\n    * n = 43261596\r\n        * b = '0b10100101000001111010011100'\r\n        * s = '00000010100101000001111010011100'\r\n        * s = '00111001011110000010100101000000'\r\n``` python\r\n    def test_reverseBits(self):\r\n        assert self.reverseBits(43261596) == 964176192\r\n        assert self.reverseBits(4294967293) == 3221225471\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due to our list slicing.\r\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-04-second-leetcode/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-10-06-another-leetcode/"},"frontmatter":{"title":"Another LeetCode Blog Post","date":"October 6, 2024"},"body":"\r\nWe're solving another LeetCode problem today. Tomorrow I will add my new project. Let's dive in.\r\n## The Problem\r\nToday's problem is **9. Palindrome Number**. The problem is as follows:\r\nGiven an integer x, return true if x is a palindrome, and false otherwise.\r\n\r\nExample 1:\r\nInput: x = 121\r\nOutput: true\r\nExplanation: 121 reads as 121 from left to right and from right to left.\r\nExample 2:\r\n\r\nExample 2:\r\nInput: x = -121\r\nOutput: false\r\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Write a function that takes the binary representation of a positive integer and returns the number of \r\nset bits it has (also known as the Hamming weight).\r\n\r\n## The Solution\r\nLet's answer using the UMPIRE method:\r\n* Understand\r\n    * We are given an integer, and we are to determine if it is a palindrome.\r\n    * In an interview. I would ask if we can solve this using strings or if I should solve it mathematically.\r\n* Match\r\n    * We can match this problem to a math problem or string problem. \r\n* Plan\r\n    * We can write a function which casts the number a string, and it will check if the first and last digits are the same until there is 1 or less digits.\r\n* Implement\r\n``` python\r\nclass Solution:\r\n    def isPalindrome(self, x: int) -> bool:\r\n        def recursivePalindrome(s: str) -> bool:\r\n            if len(s) <= 1:\r\n                return True\r\n            elif s[0] != s[-1]:\r\n                return False\r\n            return recursivePalindrome(s[1:-1])\r\n        \r\n        return recursivePalindrome(str(x))\r\n```\r\n* Review\r\n    * We implemented this using a locally defined recursive function.\r\n    * We can test our code using the examples provided.\r\n    * x = 121\r\n        * return True\r\n``` python\r\n    def test_isPalindrome(self):\r\n        assert self.test_isPalindrome(1221)\r\n        assert not self.test_isPalindrome(31)\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due the call being done n/2 times. \r\n    * Our space complexity is O(n) as we are storing the string in memory each time we recursively call.\r\n        * We can reduce the complexity to constant space by using pointers.\r\n\r\n``` python\r\n    def isPalindrome(x: int) -> bool:\r\n        s = str(x)\r\n        left = 0\r\n        right = len(s) - 1\r\n        while left < right:\r\n            if s[left] != s[right]:\r\n                return False\r\n            left += 1\r\n            right -= 1\r\n        return True\r\n```","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-06-another-leetcode/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-10-05-leetcode-procrastination/"},"frontmatter":{"title":"LeetCode as Procrastination","date":"October 5, 2024"},"body":"\r\nWe're solving another LeetCode problem today instead of adding a new project to my portfolio. This one is focused on bit manipulation. Let's dive in.\r\n## The Problem\r\nToday's problem is **191. Number of 1 bits**. The problem is as follows:\r\nWrite a function that takes the binary representation of a positive integer and returns the number of \r\nset bits it has (also known as the Hamming weight).\r\n\r\n## The Solution\r\nLet's answer using the UMPIRE method:\r\n* Understand\r\n    * We are given a positive integer, and we are to count the number of 1 bits of the number in bina.\r\n* Match\r\n    * We can match this problem to a bit manipulation problem or an array looping problem. \r\n* Plan\r\n    * We can write a function which casts the number to binary, then a string, and finally counts the number of 1's using a loop.\r\n* Implement\r\n``` python\r\n    def countBits(self, n: int) -> int:\r\n        b = bin(n)\r\n        s = str(b)[2:]\r\n        count = 0\r\n        for bit in s:\r\n            if bit == '1':\r\n                count += 1\r\n        return count\r\n```\r\n* Review\r\n    * The code is clean and concise. We used descriptive variable names.\r\n    * We can test our code using the examples provided.\r\n    * n = 4\r\n        * b = '0b0100'\r\n        * s = '0100'\r\n        * count = 1\r\n``` python\r\n    def test_reverseBits(self):\r\n        assert self.countBits(4) == 1\r\n        assert self.reverseBits(3) == 2\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due to our loop through the string.\r\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-05-leetcode-procrastination/index.mdx"}},"frontmatter":{"title":"LeetCode as Procrastination","date":"2024-10-05T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}