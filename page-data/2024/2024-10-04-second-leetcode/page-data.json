{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-10-04-second-leetcode-index-mdx","path":"/2024/2024-10-04-second-leetcode/","result":{"data":{"mdx":{"frontmatter":{"title":"Second LeetCode Blog Post"}}},"pageContext":{"slug":"/2024/2024-10-04-second-leetcode/","previous":{"fields":{"slug":"/2024/2024-10-03-first-leetcode/"},"frontmatter":{"title":"My First LeetCode Blog Post","date":"October 3, 2024"},"body":"\r\n# My First LeetCode Blog Post\r\nI have already been working on LeetCode's top interview problems. I started a couple months ago\r\nin preparation for my interviews with Google. Although that has passed, more opportunities are becoming available.\r\nSo, we are back on the grind.\r\n## The Problem\r\nToday we are working on **35. Search Insert Position**. The problem is as follows:\r\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample 1:\r\n* Input: nums = [1,3,5,6], target = 5\r\n* Output: 2\r\n\r\nExample 2:\r\n* Input: nums = [1,3,5,6], target = 2\r\n* Output: 1\r\n\r\nExample 3:\r\n* Input: nums = [1,3,5,6], target = 7\r\n* Output: 4\r\n\r\n## The Solution\r\nI like to format my answers using the UMPIRE method:\r\n* Understand\r\n    * We are given a sorted array, and we are searching for an expected value.\r\n* Match\r\n    * We can match this problem to a binary search problem, given the O(log N) complexity.\r\n* Plan\r\n    * We will want a function that takes in an array and returns an integer.\r\n* Implement\r\n``` python\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left = 0\r\n        right = len(nums) - 1\r\n        while left <= right:\r\n            mid = left + (right - left) // 2\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] < target:\r\n                left = mid + 1\r\n            else:\r\n                right = mid - 1\r\n        \r\n        return mid\r\n```\r\n* Review\r\n    * The code is clean and concise. We used descriptive variable names. We have implemented a binary search.\r\n    * We can test our code using the examples provided.\r\n    * nums = [1,3,5,6], target = 5\r\n        * left = 0, right = 3, mid = 1\r\n        * nums[1] = 3 < 5, left = 2\r\n        * nums[2] = 5 == 5, return 2\r\n    * Now let's test an edge case where the element is not in the array.\r\n    * nums = [1,3,5,6], target = 2\r\n        * left = 0, right = 3, mid = 1\r\n        * nums[1] = 3 > 2, right = 0\r\n        * nums[0] = 1 < 2, left = 1\r\n        * return 0\r\n    * We see we are not getting the expected output. We need to rework to support this edge case.\r\n* Evaluate\r\n    * We are getting the expected runtime complexity. We are not getting expected result for missing elements.\r\n    * Refactor\r\n    * We need to return the `left` pointer, not the `mid` pointer.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-03-first-leetcode/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-10-05-leetcode-procrastination/"},"frontmatter":{"title":"LeetCode as Procrastination","date":"October 5, 2024"},"body":"\r\nWe're solving another LeetCode problem today instead of adding a new project to my portfolio. This one is focused on bit manipulation. Let's dive in.\r\n## The Problem\r\nToday's problem is **191. Number of 1 bits**. The problem is as follows:\r\nWrite a function that takes the binary representation of a positive integer and returns the number of \r\nset bits it has (also known as the Hamming weight).\r\n\r\n## The Solution\r\nLet's answer using the UMPIRE method:\r\n* Understand\r\n    * We are given a positive integer, and we are to count the number of 1 bits of the number in bina.\r\n* Match\r\n    * We can match this problem to a bit manipulation problem or an array looping problem. \r\n* Plan\r\n    * We can write a function which casts the number to binary, then a string, and finally counts the number of 1's using a loop.\r\n* Implement\r\n``` python\r\n    def countBits(self, n: int) -> int:\r\n        b = bin(n)\r\n        s = str(b)[2:]\r\n        count = 0\r\n        for bit in s:\r\n            if bit == '1':\r\n                count += 1\r\n        return count\r\n```\r\n* Review\r\n    * The code is clean and concise. We used descriptive variable names.\r\n    * We can test our code using the examples provided.\r\n    * n = 4\r\n        * b = '0b0100'\r\n        * s = '0100'\r\n        * count = 1\r\n``` python\r\n    def test_reverseBits(self):\r\n        assert self.countBits(4) == 1\r\n        assert self.reverseBits(3) == 2\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due to our loop through the string.\r\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-05-leetcode-procrastination/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-10-04-second-leetcode/"},"frontmatter":{"title":"Second LeetCode Blog Post","date":"October 4, 2024"},"body":"\r\n# Second LeetCode Blog Post\r\nToday is another easy problem, and it is focused on bit manipulation.\r\nLet's dive on in.\r\n## The Problem\r\nToday's problem is **190. Reverse Bits**. The problem is as follows:\r\nReverse bits of a given 32 bits unsigned integer.\r\n\r\n## The Solution\r\nI like to format my answers using the UMPIRE method:\r\n* Understand\r\n    * We are given a 32-bit unsigned integer, and we are to reverse the bits.\r\n* Match\r\n    * We can match this problem to a bit manipulation problem.\r\n* Plan\r\n    * We can write a function which casts the number to binary, then a string, and finally reverses it before casting back to binary.\r\n* Implement\r\n``` python\r\n    def reverseBits(self, n: int) -> int:\r\n        b = bin(n)\r\n        s = str(b)[2:].zfill(32)\r\n        s = s[::-1]\r\n        return int(s, 2) \r\n```\r\n* Review\r\n    * The code is clean and concise. We used descriptive variable names. We have implemented a bit manipulation.\r\n    * We can test our code using the examples provided.\r\n    * n = 43261596\r\n        * b = '0b10100101000001111010011100'\r\n        * s = '00000010100101000001111010011100'\r\n        * s = '00111001011110000010100101000000'\r\n``` python\r\n    def test_reverseBits(self):\r\n        assert self.reverseBits(43261596) == 964176192\r\n        assert self.reverseBits(4294967293) == 3221225471\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due to our list slicing.\r\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-04-second-leetcode/index.mdx"}},"frontmatter":{"title":"Second LeetCode Blog Post","date":"2024-10-04T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}