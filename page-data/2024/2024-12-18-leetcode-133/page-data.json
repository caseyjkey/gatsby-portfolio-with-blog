{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-12-18-leetcode-133-index-mdx","path":"/2024/2024-12-18-leetcode-133/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 133. Clone Graph"}}},"pageContext":{"slug":"/2024/2024-12-18-leetcode-133/","previous":{"fields":{"slug":"/2024/2024-12-14-leetcode-173/"},"frontmatter":{"title":"LeetCode 173. Binary Search Tree Iterator","date":"December 14, 2024"},"body":"\r\nHere are two solutions. One is recursive and the other iterative.\r\nThe iterative solution is better as it can handle larger inputs.\r\n\r\n# Solution\r\nRecursive\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass BSTIterator:\r\n\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.nodes = deque([])\r\n\r\n        def traverse(node):\r\n            if not node:\r\n                return\r\n            \r\n            traverse(node.left)\r\n            self.nodes.append(node.val)\r\n            traverse(node.right)\r\n        \r\n        traverse(root)\r\n        \r\n\r\n    def next(self) -> int:\r\n        return self.nodes.popleft()\r\n\r\n    def hasNext(self) -> bool:\r\n        return len(self.nodes) > 0\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n```\r\nTime complexity is O(n) = n and space complexity is O(h).\r\n\r\niterative\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass BSTIterator:\r\n\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.nodes = []\r\n        self.pushAll(root)      \r\n\r\n    def next(self) -> int:\r\n        node = self.nodes.pop()\r\n        self.pushAll(node.right)\r\n        return node.val\r\n\r\n    def hasNext(self) -> bool:\r\n        return len(self.nodes) > 0\r\n    \r\n    def pushAll(self, node):\r\n        while node:\r\n            self.nodes.append(node)\r\n            node = node.left\r\n\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n```\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-14-leetcode-173/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-12-21-leetcode-77/"},"frontmatter":{"title":"LeetCode 77. Combinations","date":"December 21, 2024"},"body":"\r\nI've been working on backtracking problems. For this one, it helped to visualize the \r\nrecursion stack using [Python Tutor](https://pythontutor.com/visualize.html#mode=edit).\r\nAlso, I will have to revisit this later as the complexity analysis is out-of-the-ordinary.\r\n\r\n# Solution\r\n```python\r\nclass Solution:\r\n    def combine(self, n: int, k: int) -> List[List[int]]:\r\n        nums = [n for n in range(1, n + 1)]\r\n        results = []\r\n        def backtrack(nums, result):\r\n            if len(result) == k:\r\n                results.append(result[:])\r\n                return\r\n            \r\n            while nums:\r\n                backtrack(nums[1:], result + [nums.pop(0)])\r\n        \r\n        backtrack(nums, [])\r\n        return results\r\n```\r\nThe time complexity is O(N choose K) since for each frame of the recursion stack, we work on N-i subproblems, where i is from 0 to k. The space complexity is O(k * n choose k) since each result requires k space. \r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-21-leetcode-77/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-12-18-leetcode-133/"},"frontmatter":{"title":"LeetCode 133. Clone Graph","date":"December 18, 2024"},"body":"\r\nThis problem stumped me for a while because I needed to use a dictionary to make sure I didn't have duplicate copies, then I also forgot to return the copy at the end of the DFS algorithm.\r\n\r\n# Solution\r\n```python\r\n\"\"\"\r\n# Definition for a Node.\r\nclass Node:\r\n    def __init__(self, val = 0, neighbors = None):\r\n        self.val = val\r\n        self.neighbors = neighbors if neighbors is not None else []\r\n\"\"\"\r\nfrom typing import Optional\r\nclass Solution:\r\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\r\n        if not node:\r\n            return None\r\n\r\n        copies = {}\r\n\r\n        def dfs(node):\r\n            if node in copies:\r\n                return copies[node]\r\n            \r\n            copy = Node(node.val)\r\n            copies[node] = copy\r\n            for n in node.neighbors:\r\n                copy.neighbors.append(dfs(n))\r\n            \r\n            return copy\r\n        \r\n        dfs(node)\r\n\r\n        return copies[node]\r\n```\r\nThe time complexity is O(V + E) since we visit every node and edge once, and then the space complexity is O(V) because our copies dictionary is always the number of verticies in the graph. The recursive call stack is also at worst case O(V) space complexity.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-18-leetcode-133/index.mdx"}},"frontmatter":{"title":"LeetCode 133. Clone Graph","date":"2024-12-18T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}