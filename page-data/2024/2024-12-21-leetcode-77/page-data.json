{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-12-21-leetcode-77-index-mdx","path":"/2024/2024-12-21-leetcode-77/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 77. Combinations"}}},"pageContext":{"slug":"/2024/2024-12-21-leetcode-77/","previous":{"fields":{"slug":"/2024/2024-12-18-leetcode-133/"},"frontmatter":{"title":"LeetCode 133. Clone Graph","date":"December 18, 2024"},"body":"\r\nThis problem stumped me for a while because I needed to use a dictionary to make sure I didn't have duplicate copies, then I also forgot to return the copy at the end of the DFS algorithm.\r\n\r\n# Solution\r\n```python\r\n\"\"\"\r\n# Definition for a Node.\r\nclass Node:\r\n    def __init__(self, val = 0, neighbors = None):\r\n        self.val = val\r\n        self.neighbors = neighbors if neighbors is not None else []\r\n\"\"\"\r\nfrom typing import Optional\r\nclass Solution:\r\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\r\n        if not node:\r\n            return None\r\n\r\n        copies = {}\r\n\r\n        def dfs(node):\r\n            if node in copies:\r\n                return copies[node]\r\n            \r\n            copy = Node(node.val)\r\n            copies[node] = copy\r\n            for n in node.neighbors:\r\n                copy.neighbors.append(dfs(n))\r\n            \r\n            return copy\r\n        \r\n        dfs(node)\r\n\r\n        return copies[node]\r\n```\r\nThe time complexity is O(V + E) since we visit every node and edge once, and then the space complexity is O(V) because our copies dictionary is always the number of verticies in the graph. The recursive call stack is also at worst case O(V) space complexity.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-18-leetcode-133/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-12-25-leetcode-22/"},"frontmatter":{"title":"LeetCode 22. Generate Parentheses","date":"December 25, 2024"},"body":"\r\nHere's another backtracking problem. For this post, I'd like to discuss the differences between\r\nmy solution and another submitted solution.\r\n\r\n# My Solution\r\n```python\r\nclass Solution:\r\n    def generateParenthesis(self, n: int) -> List[str]:\r\n        results = []\r\n        def backtrack(openP, closedP, curr):\r\n            if openP == n and closedP == n:\r\n                results.append(''.join(curr))\r\n                return\r\n            \r\n            if openP != n:\r\n                curr.append('(')\r\n                backtrack(openP + 1, closedP, curr)\r\n                curr.pop()\r\n\r\n            if closedP < openP:\r\n                curr.append(')')\r\n                backtrack(openP, closedP + 1, curr)\r\n                curr.pop()\r\n\r\n        backtrack(0, 0, [])\r\n        return results\r\n```\r\nThe time complexity is O(2n * Catalan(n)) since for each solution (there are Catalan(n))  of the recursion stack, we work on N-i subproblems, where i is from 0 to k. The space complexity is O(k * n choose k) since each result requires k space. \r\n# niits' Solution\r\n```python\r\nclass Solution:\r\n    def generateParenthesis(self, n: int) -> List[str]:\r\n        res = []\r\n\r\n        def dfs(openP, closeP, s):\r\n            if openP == closeP and openP + closeP == n * 2:\r\n                res.append(s)\r\n                return\r\n            \r\n            if openP < n:\r\n                dfs(openP + 1, closeP, s + \"(\")\r\n            \r\n            if closeP < openP:\r\n                dfs(openP, closeP + 1, s + \")\")\r\n\r\n        dfs(0, 0, \"\")\r\n\r\n        return res\r\n```\r\nThe main differences I see are the base case and use of string concatanation.\r\nI believe there is marginal difference in time complexity for my equality checks\r\nand niits' addition plus multiplication equality. My solution is more readable.\r\nThe use of string concatanation by niits' is easier to read, but it uses more memory\r\nas each recursive call creates a new string while mine is passed between each recursive call.\r\nThe duplication of strings by recursive calls adds an average of 2n complexity to the \r\nexisting 2n complexity found in my solution.","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-25-leetcode-22/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-12-21-leetcode-77/"},"frontmatter":{"title":"LeetCode 77. Combinations","date":"December 21, 2024"},"body":"\r\nI've been working on backtracking problems. For this one, it helped to visualize the \r\nrecursion stack using [Python Tutor](https://pythontutor.com/visualize.html#mode=edit).\r\nAlso, I will have to revisit this later as the complexity analysis is out-of-the-ordinary.\r\n\r\n# Solution\r\n```python\r\nclass Solution:\r\n    def combine(self, n: int, k: int) -> List[List[int]]:\r\n        nums = [n for n in range(1, n + 1)]\r\n        results = []\r\n        def backtrack(nums, result):\r\n            if len(result) == k:\r\n                results.append(result[:])\r\n                return\r\n            \r\n            while nums:\r\n                backtrack(nums[1:], result + [nums.pop(0)])\r\n        \r\n        backtrack(nums, [])\r\n        return results\r\n```\r\nThe time complexity is O(N choose K) since for each frame of the recursion stack, we work on N-i subproblems, where i is from 0 to k. The space complexity is O(k * n choose k) since each result requires k space. \r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-21-leetcode-77/index.mdx"}},"frontmatter":{"title":"LeetCode 77. Combinations","date":"2024-12-21T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}