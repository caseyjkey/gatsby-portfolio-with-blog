{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-11-28-leetcode-105-index-mdx","path":"/2024/2024-11-28-leetcode-105/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 105. Construct Binary Tree from Preoder and Inorder Traversal"}}},"pageContext":{"slug":"/2024/2024-11-28-leetcode-105/","previous":{"fields":{"slug":"/2024/2024-11-26-leetcode-146/"},"frontmatter":{"title":"LeetCode 146. LRU Cache","date":"November 26, 2024"},"body":"\r\nThis took me a few days although it's only a medium! It is important to remember Python is pass-by-reference.\r\nI spent a lot of time debugging because I didn't mirror changes between previous and next nodes when moving a node between them.\r\nI was able to debug by creating a list of key-value pairs then printing the list after each operation.\r\n\r\n\r\n# Solution\r\n```python\r\nclass Node:\r\n    def __init__(self, key=0, val=0, prev=None, next=None):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = prev\r\n        self.next = next\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.d = {}\r\n        self.l = None\r\n        self.start = None\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.d:\r\n            node = self.d[key]\r\n            if node.prev and node.next:\r\n                node.prev.next = node.next\r\n                node.next.prev = node.prev\r\n            elif node.next:\r\n                self.start = node.next\r\n                self.start.prev = None\r\n            if self.l != node:\r\n                node.prev = self.l\r\n                self.l.next = node\r\n                self.l = self.l.next\r\n                self.l.next = None\r\n            return node.val\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if not key in self.d:\r\n            if self.size == self.capacity:\r\n                node = self.start\r\n                del self.d[node.key]\r\n                self.start = node.next\r\n                if self.start:\r\n                    self.start.prev = None\r\n                self.size -= 1\r\n            if self.l:\r\n                self.l.next = Node(key, value, self.l)\r\n                self.l = self.l.next\r\n            if not self.start:\r\n                self.start = Node(key, value)\r\n                self.l = self.start\r\n            self.d[key] = self.l\r\n            self.size += 1\r\n        else:\r\n            node = self.d[key]\r\n            if node == self.start and self.start.next:\r\n                self.start = self.start.next\r\n                self.start.prev = None\r\n            if node.prev and node.next:\r\n                node.prev.next = node.next\r\n                node.next.prev = node.prev\r\n            if node != self.l:\r\n                node.prev = self.l\r\n                self.l.next = node\r\n            node.val = value\r\n            node.next = None\r\n            self.l = node\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\nTime complexity for get and put operations are O(n) = 1 and space complexity is O(n) due to the dictionary holding each element.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-26-leetcode-146/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-12-05-leetcode-236/"},"frontmatter":{"title":"LeetCode 236. Lowest Common Ancestor of a Binary Tree","date":"December 5, 2024"},"body":"\r\nThis is the last month of my goal toward 150 problems done by 2025. I'll have to pick up more than a few problems this weekend. I have 56 problems remaining.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        if root in (None, p, q): return root\r\n        left, right = [self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)]\r\n        return root if left and right else left or right\r\n            \r\n\r\n```\r\nTime complexity is O(n) = n and space complexity is O(h) where the height is h. Best case the height is log(n) as a balanced tree and worst case is n as a skewed tree.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-05-leetcode-236/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-11-28-leetcode-105/"},"frontmatter":{"title":"LeetCode 105. Construct Binary Tree from Preoder and Inorder Traversal","date":"November 28, 2024"},"body":"\r\nHappy Thanksgiving! I am happy to have solved this without looking up a solution. However, I did have to review traversals.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\r\n        top = deque(preorder)\r\n        bottom = deque(inorder)\r\n        nodes = []\r\n        seen = set()\r\n\r\n        root = parent = TreeNode()\r\n        while top:\r\n            parent.right = TreeNode(top.popleft())\r\n            left = parent.right\r\n            seen.add(left.val)\r\n            nodes.append(left)\r\n            while left.val != bottom[0]:\r\n                left.left = TreeNode(top.popleft())\r\n                left = left.left\r\n                seen.add(left.val)\r\n                nodes.append(left)\r\n            while bottom and bottom[0] in seen:\r\n                bottom.popleft()\r\n                parent = nodes.pop()\r\n            \r\n        return root.right\r\n```\r\nTime complexity is O(n) = n and space complexity is O(n) due to set and deques.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-28-leetcode-105/index.mdx"}},"frontmatter":{"title":"LeetCode 105. Construct Binary Tree from Preoder and Inorder Traversal","date":"2024-11-28T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}