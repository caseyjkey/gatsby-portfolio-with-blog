{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-12-12-leetcode-103-index-mdx","path":"/2024/2024-12-12-leetcode-103/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 103. Binary Tree Zigzag Level Order Traversal"}}},"pageContext":{"slug":"/2024/2024-12-12-leetcode-103/","previous":{"fields":{"slug":"/2024/2024-12-05-leetcode-236/"},"frontmatter":{"title":"LeetCode 236. Lowest Common Ancestor of a Binary Tree","date":"December 5, 2024"},"body":"\r\nThis is the last month of my goal toward 150 problems done by 2025. I'll have to pick up more than a few problems this weekend. I have 56 problems remaining.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        if root in (None, p, q): return root\r\n        left, right = [self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)]\r\n        return root if left and right else left or right\r\n            \r\n\r\n```\r\nTime complexity is O(n) = n and space complexity is O(h) where the height is h. Best case the height is log(n) as a balanced tree and worst case is n as a skewed tree.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-05-leetcode-236/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-12-14-leetcode-173/"},"frontmatter":{"title":"LeetCode 173. Binary Search Tree Iterator","date":"December 14, 2024"},"body":"\r\nHere are two solutions. One is recursive and the other iterative.\r\nThe iterative solution is better as it can handle larger inputs.\r\n\r\n# Solution\r\nRecursive\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass BSTIterator:\r\n\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.nodes = deque([])\r\n\r\n        def traverse(node):\r\n            if not node:\r\n                return\r\n            \r\n            traverse(node.left)\r\n            self.nodes.append(node.val)\r\n            traverse(node.right)\r\n        \r\n        traverse(root)\r\n        \r\n\r\n    def next(self) -> int:\r\n        return self.nodes.popleft()\r\n\r\n    def hasNext(self) -> bool:\r\n        return len(self.nodes) > 0\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n```\r\nTime complexity is O(n) = n and space complexity is O(h).\r\n\r\niterative\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass BSTIterator:\r\n\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.nodes = []\r\n        self.pushAll(root)      \r\n\r\n    def next(self) -> int:\r\n        node = self.nodes.pop()\r\n        self.pushAll(node.right)\r\n        return node.val\r\n\r\n    def hasNext(self) -> bool:\r\n        return len(self.nodes) > 0\r\n    \r\n    def pushAll(self, node):\r\n        while node:\r\n            self.nodes.append(node)\r\n            node = node.left\r\n\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n```\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-14-leetcode-173/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-12-12-leetcode-103/"},"frontmatter":{"title":"LeetCode 103. Binary Tree Zigzag Level Order Traversal","date":"December 12, 2024"},"body":"\r\nI am glad I was able to make a solution from my own intuition.\r\n\r\n# Solution\r\n```python\r\nfrom collections import deque\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        nodes = deque([root] if root else [])\r\n        rightToLeft = False\r\n\r\n        result = []\r\n        while nodes:\r\n            level = []\r\n            children = deque([])\r\n            for i in range(len(nodes)):\r\n                if rightToLeft:\r\n                    node = nodes.pop()\r\n                    node.right and children.appendleft(node.right)\r\n                    node.left and children.appendleft(node.left)\r\n                else:\r\n                    node = nodes.popleft()\r\n                    node.left and children.append(node.left)\r\n                    node.right and children.append(node.right)\r\n                level.append(node.val)\r\n            result.append(level)\r\n            if rightToLeft:\r\n                nodes += children\r\n            else:\r\n                nodes = children + nodes\r\n            rightToLeft = not rightToLeft\r\n        return result\r\n```\r\nTime complexity is O(n) = n and space complexity is O(n).\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-12-12-leetcode-103/index.mdx"}},"frontmatter":{"title":"LeetCode 103. Binary Tree Zigzag Level Order Traversal","date":"2024-12-12T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}