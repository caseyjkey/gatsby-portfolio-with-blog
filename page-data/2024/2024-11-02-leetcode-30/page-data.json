{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-11-02-leetcode-30-index-mdx","path":"/2024/2024-11-02-leetcode-30/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 30. Substring with Concatenation of All Words"}}},"pageContext":{"slug":"/2024/2024-11-02-leetcode-30/","previous":{"fields":{"slug":"/2024/2024-11-01-leetcode-68/"},"frontmatter":{"title":"LeetCode 68. Text Justification","date":"November 1, 2024"},"body":"\nThis took a while to solve. I completed it over two days, then I had the help of ChatGPT to analyze the complexity.\nI reviewed other answers and I didn't find simpler methods.\n\n# Solution\n```python\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        width = 0\n        rows = []\n        row = []\n        for word in words:\n            line = ' '.join(row + [word])\n            if len(line) > maxWidth:\n                charCount = len(''.join(row))\n                spaceRemaining = maxWidth - charCount\n                if len(row) > 1:\n                    spaces = [spaceRemaining // (len(row) - 1) for _ in range(len(row) - 1)]\n                    for i in range(spaceRemaining % (len(row) - 1)):\n                        spaces[i] += 1\n                else:\n                    spaces = [spaceRemaining]\n                print(spaces, row)\n                line = ''\n                for i in range(len(row)):\n                    line += row[i]\n                    if i < len(spaces):\n                        line += ' ' * spaces[i]\n                rows.append(line)\n                row = []\n            row.append(word)\n\n        charCount = len(' '.join(row))\n        spaceRemaining = maxWidth - charCount\n        line = ' '.join(row)\n        line += ' ' * spaceRemaining\n        rows.append(line)\n        return rows\n\n```\nO(n) = n * m where n is the number of words and m is the average row length\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-01-leetcode-68/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-11-03-leetcode-76/"},"frontmatter":{"title":"LeetCode 76. Minimum Window Substring","date":"November 3, 2024"},"body":"\nLast problem for this study set's sliding window problems.\n\n# Solution\nThis is my initial greedy solution. It passes initial test cases, but fails longer inputs.\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        def containsT(substring):\n            letters = list(t[:])\n            for i in substring:\n                if i in letters:\n                    letters.remove(i)\n            return len(letters) == 0\n\n        n = len(t)\n        m = len(s)\n        windowSize = n\n        while windowSize <= m:\n            for i in range(0, m):\n                substring = s[i:i+windowSize]\n                if containsT(substring):\n                    return substring\n            windowSize += 1\n        return \"\"\n```\nNow to optimize my solution, I plan on stepping through the `s` string, and tracking how many counts of `t` letters are found. This should be faster as we are keeping track of letter counts as we go, instead of searching for all letters in the substring for each iteration.\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        letterCounts = dict()\n        for letter in t:\n            if letter in letterCounts:\n                letterCounts[letter] += 1\n            else:\n                letterCounts[letter] = 1\n        \n        start = 0\n        end = 0\n        windowLength = len(s) + 1\n        minStart = 0\n        lettersRemaining = len(t)\n\n        while end < len(s):\n            if s[end] in letterCounts:\n                if letterCounts[s[end]] > 0:\n                    lettersRemaining -= 1\n                letterCounts[s[end]] -= 1\n            \n            while lettersRemaining == 0:\n                if end - start + 1 < windowLength:\n                    windowLength = end - start + 1\n                    minStart = start\n                if s[start] in letterCounts:\n                    letterCounts[s[start]] += 1\n                    if letterCounts[s[start]] > 0:\n                        lettersRemaining += 1\n                start += 1\n            end += 1\n\n        if windowLength == len(s) + 1:\n            return \"\"\n        else:\n            return s[minStart:minStart + windowLength]\n\n        return \"\"\n```\t\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-03-leetcode-76/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-11-02-leetcode-30/"},"frontmatter":{"title":"LeetCode 30. Substring with Concatenation of All Words","date":"November 2, 2024"},"body":"\nStarting with a hard problem today.\n\n# Solution\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        lenTotal = len(''.join(words))\n        perms = set()\n        def permutations(head, tail):\n            if not len(head):\n                perms.add(tail)\n            for i in range(len(head)):\n                permutations(head[:i] + head[i+1:], tail + head[i])\n        permutations(words, '')\n\n        result = []\n        for i in range(0, len(s)):\n            if s[i:i+lenTotal] in perms:\n                result.append(i)\n        \n        return result\n```\nThis solution times out. It has a time complexity of O(n) = n! due to the permutations method.\n\nI'm going to try again using python's `itertools.permutations` method. However, this lead to an out of memory error.\nRethinking the algorithm, we can remove the step where we find all permutations. Instead, we will replace our `perms` set with a method called `validSubstring(substring)`. This method will use a copy of the list of words, and we will loop through the substring and remove any word occurrences. If we always find a word at each step in our substring, we return True. We improve the efficiency of our algorithm by caching the result of each substring as either `validSubstring` or `invalidSubstring` set members. This solution is accepted.\n\n````python\nimport itertools\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if len(s) < len(''.join(words)):\n            return []\n\n        wordLen = len(words[0])\n        def validSubstring(substring):\n            wordsTemp = words[:]\n            for i in range(0, len(substring), wordLen):\n                currWord = substring[i:i + wordLen]\n                if currWord in wordsTemp:\n                    wordsTemp.remove(currWord)\n                else:\n                    return False\n            return True\n        \n        invalidSubstrings = set()\n        validSubstrings = set()\n        wordsLen = wordLen * len(words)\n        window = s[:wordsLen]\n        res = []\n        if validSubstring(window):\n            validSubstrings.add(window)\n            res.append(0)\n\n        for i in range(wordsLen, len(s)):\n            letter = s[i]\n            window = window[1:]\n            window += letter\n            if window not in invalidSubstrings:\n                if window in validSubstrings or validSubstring(window):\n                    res.append(i - wordsLen + 1)\n                    validSubstrings.add(window)\n                else:\n                    invalidSubstrings.add(window)\n        \n        return res\n```\nThe time complexity is O(n) = n * k^2 where k is the number of words. It is k^2 because we loop through k words and the remove operation is O(k) = k. \n\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-02-leetcode-30/index.mdx"}},"frontmatter":{"title":"LeetCode 30. Substring with Concatenation of All Words","date":"2024-11-02T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}