{"componentChunkName":"component---src-templates-blog-post-template-tsx-content-file-path-posts-2024-2024-11-04-leetcode-36-index-mdx","path":"/2024/2024-11-04-leetcode-36/","result":{"data":{"mdx":{"frontmatter":{"title":"LeetCode 36. Valid Sudoku"}}},"pageContext":{"slug":"/2024/2024-11-04-leetcode-36/","previous":{"fields":{"slug":"/2024/2024-11-03-leetcode-76/"},"frontmatter":{"title":"LeetCode 76. Minimum Window Substring","date":"November 3, 2024"},"body":"\nLast problem for this study set's sliding window problems.\n\n# Solution\nThis is my initial greedy solution. It passes initial test cases, but fails longer inputs.\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        def containsT(substring):\n            letters = list(t[:])\n            for i in substring:\n                if i in letters:\n                    letters.remove(i)\n            return len(letters) == 0\n\n        n = len(t)\n        m = len(s)\n        windowSize = n\n        while windowSize <= m:\n            for i in range(0, m):\n                substring = s[i:i+windowSize]\n                if containsT(substring):\n                    return substring\n            windowSize += 1\n        return \"\"\n```\nNow to optimize my solution, I plan on stepping through the `s` string, and tracking how many counts of `t` letters are found. This should be faster as we are keeping track of letter counts as we go, instead of searching for all letters in the substring for each iteration.\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        letterCounts = dict()\n        for letter in t:\n            if letter in letterCounts:\n                letterCounts[letter] += 1\n            else:\n                letterCounts[letter] = 1\n        \n        start = 0\n        end = 0\n        windowLength = len(s) + 1\n        minStart = 0\n        lettersRemaining = len(t)\n\n        while end < len(s):\n            if s[end] in letterCounts:\n                if letterCounts[s[end]] > 0:\n                    lettersRemaining -= 1\n                letterCounts[s[end]] -= 1\n            \n            while lettersRemaining == 0:\n                if end - start + 1 < windowLength:\n                    windowLength = end - start + 1\n                    minStart = start\n                if s[start] in letterCounts:\n                    letterCounts[s[start]] += 1\n                    if letterCounts[s[start]] > 0:\n                        lettersRemaining += 1\n                start += 1\n            end += 1\n\n        if windowLength == len(s) + 1:\n            return \"\"\n        else:\n            return s[minStart:minStart + windowLength]\n\n        return \"\"\n```\t\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-03-leetcode-76/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-11-05-leetcode-48/"},"frontmatter":{"title":"LeetCode 48. Rotate Image","date":"November 5, 2024"},"body":"\nWorking through more matrix problems today.\n\n# Solution\nI used a method where we transpose the matrix, then reverse the rows. This is memory efficient in space and locality.\n```python\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        for i in range(len(matrix)):\n            for j in range(i+1, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(len(matrix)):\n            matrix[i] = matrix[i][::-1]\n        \n        return matrix\n```\n(n) = n^2 since we have nested loops dependent on input size.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-05-leetcode-48/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-11-04-leetcode-36/"},"frontmatter":{"title":"LeetCode 36. Valid Sudoku","date":"November 4, 2024"},"body":"\nNow, I am working on matrix problems. \n\n# Solution\nThis is my initial greedy solution.\n```python\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        for row in board:\n            rowVals = set()\n            for column in row:\n                if column != '.' and column in rowVals:\n                    return False\n                rowVals.add(column)\n\n        for col in range(len(board[0])):\n            colVals = set()\n            for row in board:\n                if row[col] != '.' and row[col] in colVals:\n                    return False\n                colVals.add(row[col])\n\n        for subX in range(3):\n            for subY in range(3):\n                gridVals = set()\n                for x in range(3):\n                    for y in range(3):\n                        cell = board[subY * 3 + y][subX * 3 + x]\n                        if cell != '.' and cell in gridVals:\n                            return False\n                        gridVals.add(board[subY * 3 + y][subX * 3 + x])\n        \n        return True\n```\t\n\n## Improvements\nNow, I reviewed other solutions and liked this one which uses a list of tuples and only one nested for loop.\n```python\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        vals = []\n        for i, row in enumerate(board):\n            for j, x in enumerate(row):\n                if x != '.':\n                    vals += [(x, j), (i, x), (x, i // 3, j // 3)]\n        return len(vals) == len(set(vals))\n```\nI like how tuples are made unique by swapping their position, and the cell value is not mistaken for the row/column because it is a string rather than int.\nO(n) = 1 since board size is fixed.\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-11-04-leetcode-36/index.mdx"}},"frontmatter":{"title":"LeetCode 36. Valid Sudoku","date":"2024-11-04T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}