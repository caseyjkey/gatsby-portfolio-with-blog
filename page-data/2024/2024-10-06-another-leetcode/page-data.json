{"componentChunkName":"component---src-templates-blog-post-template-jsx-content-file-path-posts-2024-2024-10-06-another-leetcode-index-mdx","path":"/2024/2024-10-06-another-leetcode/","result":{"data":{"mdx":{"frontmatter":{"title":"Another LeetCode Blog Post"}}},"pageContext":{"slug":"/2024/2024-10-06-another-leetcode/","previous":{"fields":{"slug":"/2024/2024-10-05-leetcode-procrastination/"},"frontmatter":{"title":"LeetCode as Procrastination","date":"October 5, 2024"},"body":"\r\nWe're solving another LeetCode problem today instead of adding a new project to my portfolio. This one is focused on bit manipulation. Let's dive in.\r\n## The Problem\r\nToday's problem is **191. Number of 1 bits**. The problem is as follows:\r\nWrite a function that takes the binary representation of a positive integer and returns the number of \r\nset bits it has (also known as the Hamming weight).\r\n\r\n## The Solution\r\nLet's answer using the UMPIRE method:\r\n* Understand\r\n    * We are given a positive integer, and we are to count the number of 1 bits of the number in bina.\r\n* Match\r\n    * We can match this problem to a bit manipulation problem or an array looping problem. \r\n* Plan\r\n    * We can write a function which casts the number to binary, then a string, and finally counts the number of 1's using a loop.\r\n* Implement\r\n``` python\r\n    def countBits(self, n: int) -> int:\r\n        b = bin(n)\r\n        s = str(b)[2:]\r\n        count = 0\r\n        for bit in s:\r\n            if bit == '1':\r\n                count += 1\r\n        return count\r\n```\r\n* Review\r\n    * The code is clean and concise. We used descriptive variable names.\r\n    * We can test our code using the examples provided.\r\n    * n = 4\r\n        * b = '0b0100'\r\n        * s = '0100'\r\n        * count = 1\r\n``` python\r\n    def test_reverseBits(self):\r\n        assert self.countBits(4) == 1\r\n        assert self.reverseBits(3) == 2\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due to our loop through the string.\r\n    * Our space complexity is O(1) as we use the same amount of space regardless of input size.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-05-leetcode-procrastination/index.mdx"}},"next":{"fields":{"slug":"/2024/2024-10-07-intro-to-cursor/"},"frontmatter":{"title":"Intro to Cursor","date":"October 7, 2024"},"body":"\r\nToday I decided to embrace the AI revolution and try out Cursor. I'm going to write a quick LeetCode solution, then dive into some project ideas.\r\n\r\n# LeetCode Problem\r\n## The Problem\r\nSince we have some help from Cursor tonight, we wil be solving a hard problem.\r\nToday's problem is **4. Median of Two Sorted Arrays**. The problem is as follows:\r\n\r\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\r\n\r\nThe overall run time complexity should be O(log (m+n)).\r\n\r\nExample 1:\r\n    Input: nums1 = [1,3], nums2 = [2]\r\n    Output: 2.00000\r\n    Explanation: merged array = [1,2,3] and median is 2.\r\n\r\nExample 2:\r\n    Input: nums1 = [1,2], nums2 = [3,4]\r\n    Output: 2.50000\r\n    Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\r\n\r\n## The Solution\r\nLet's answer using the UMPIRE method:\r\n* Understand\r\n    * We have two sorted arrays, and we must merge them and find the median.\r\n    * The median is the middle value of a sorted list. If the list has an even number of elements, the median is the average of the two middle elements.\r\n* Match\r\n    * We can merge the two arrays and then find the median, but this would not be O(log(m+n)).\r\n    * We can use a modified binary search to find the median.\r\n        * Binary search is O(log n) and we can use it to find the median.\r\n* Plan\r\n    * We can use a modified binary search to find the median.\r\n    * We will use two pointers to traverse the arrays.\r\n    * We will use a helper function to find the median of the two arrays.\r\n* Implement\r\n```python\r\nclass Solution:\r\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\r\n        # Ensure nums1 is the smaller array\r\n        if len(nums1) > len(nums2):\r\n            nums1, nums2 = nums2, nums1\r\n        \r\n        m, n = len(nums1), len(nums2)\r\n        total_length = m + n\r\n        half = (total_length + 1) // 2\r\n        \r\n        left, right = 0, m\r\n        \r\n        while left <= right:\r\n            partition1 = (left + right) // 2\r\n            partition2 = half - partition1\r\n            \r\n            left1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')\r\n            right1 = nums1[partition1] if partition1 < m else float('inf')\r\n            left2 = nums2[partition2 - 1] if partition2 > 0 else float('-inf')\r\n            right2 = nums2[partition2] if partition2 < n else float('inf')\r\n            \r\n            if left1 <= right2 and left2 <= right1:\r\n                # We have found the correct partition\r\n                if total_length % 2 == 0:\r\n                    return (max(left1, left2) + min(right1, right2)) / 2\r\n                else:\r\n                    return max(left1, left2)\r\n            elif left1 > right2:\r\n                right = partition1 - 1\r\n            else:\r\n                left = partition1 + 1\r\n        \r\n        raise ValueError(\"Input arrays are not sorted\")\r\n\r\n```\r\n* Review\r\n    * The code is clean, it uses descriptive variables and follows a logical flow.\r\n    * The code is correct, it passes the test cases.\r\n* Evaluate\r\n    * The code is efficient, it runs in O(log(m+n)) time.\r\n    * We never iterate over the entire array, even in the worst case.\r\n\r\n## Notes\r\nCursor generates duplicate responses. I had to remove unnecessary text.\r\nIt does not appear to elaborate on its reasoning.\r\nElaborating on specific parts is easy using the annotated keyboard commands.\r\nUsing cursor to write LeetCode solutions is great, but it won't be useful for interviews.\r\nHopefully it will be as useful for projects.\r\nIt would be nice if I could tab through the suggestions, rather than using tab to accept current suggestion.\r\nCursor has been a drop-in replacement for Code, requiring no configuration to continue prior development workflow.\r\n\r\n# Project Ideas\r\nI had a few ideas for projects I want to build.\r\n* A wallpaper web app that scrapes image boards.\r\n    * It would have authentication for user accounts.\r\n        * Users can favorite wallpapers, saving them for later.\r\n        * Users can download wallpapers, saving bandwidth compared to anonymous access.\r\n    * It would hide NSFW wallpapers by parsing post text.\r\n* A scholarship essay assistant.\r\n    * It would use RAG to import past essays as context during prompts.\r\n    * It would use GPT-4o to proofread and improve essays.\r\n    * It would track scholarship deadlines.\r\n    * It would save essays to a user's Google Drive.\r\n\r\nI will use the wallpaper app to learn Next.js and Tailwind.\r\nI don't expect to spend much time on it, as it can only be monetized through ads.\r\nI will use the scholarship essay assistant to learn about:\r\n    * RAG,\r\n    * GPT-4o,\r\n    * Google Drive API,\r\n    * Docker,\r\n    * AWS,\r\n    * React,\r\n    * and TypeScript.\r\n","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-07-intro-to-cursor/index.mdx"}},"post":{"fields":{"slug":"/2024/2024-10-06-another-leetcode/"},"frontmatter":{"title":"Another LeetCode Blog Post","date":"October 6, 2024"},"body":"\r\nWe're solving another LeetCode problem today. Tomorrow I will add my new project. Let's dive in.\r\n## The Problem\r\nToday's problem is **9. Palindrome Number**. The problem is as follows:\r\nGiven an integer x, return true if x is a palindrome, and false otherwise.\r\n\r\nExample 1:\r\nInput: x = 121\r\nOutput: true\r\nExplanation: 121 reads as 121 from left to right and from right to left.\r\nExample 2:\r\n\r\nExample 2:\r\nInput: x = -121\r\nOutput: false\r\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Write a function that takes the binary representation of a positive integer and returns the number of \r\nset bits it has (also known as the Hamming weight).\r\n\r\n## The Solution\r\nLet's answer using the UMPIRE method:\r\n* Understand\r\n    * We are given an integer, and we are to determine if it is a palindrome.\r\n    * In an interview. I would ask if we can solve this using strings or if I should solve it mathematically.\r\n* Match\r\n    * We can match this problem to a math problem or string problem. \r\n* Plan\r\n    * We can write a function which casts the number a string, and it will check if the first and last digits are the same until there is 1 or less digits.\r\n* Implement\r\n``` python\r\nclass Solution:\r\n    def isPalindrome(self, x: int) -> bool:\r\n        def recursivePalindrome(s: str) -> bool:\r\n            if len(s) <= 1:\r\n                return True\r\n            elif s[0] != s[-1]:\r\n                return False\r\n            return recursivePalindrome(s[1:-1])\r\n        \r\n        return recursivePalindrome(str(x))\r\n```\r\n* Review\r\n    * We implemented this using a locally defined recursive function.\r\n    * We can test our code using the examples provided.\r\n    * x = 121\r\n        * return True\r\n``` python\r\n    def test_isPalindrome(self):\r\n        assert self.test_isPalindrome(1221)\r\n        assert not self.test_isPalindrome(31)\r\n```\r\n* Evaluate\r\n    * Our code runs in O(n) time complexity due the call being done n/2 times. \r\n    * Our space complexity is O(n) as we are storing the string in memory each time we recursively call.\r\n        * We can reduce the complexity to constant space by using pointers.\r\n\r\n``` python\r\n    def isPalindrome(x: int) -> bool:\r\n        s = str(x)\r\n        left = 0\r\n        right = len(s) - 1\r\n        while left < right:\r\n            if s[left] != s[right]:\r\n                return False\r\n            left += 1\r\n            right -= 1\r\n        return True\r\n```","internal":{"contentFilePath":"/home/trill/Development/gatsby-portfolio-with-blog/posts/2024/2024-10-06-another-leetcode/index.mdx"}},"frontmatter":{"title":"Another LeetCode Blog Post","date":"2024-10-06T00:00:00.000Z","published":true}}},"staticQueryHashes":[],"slicesMap":{}}