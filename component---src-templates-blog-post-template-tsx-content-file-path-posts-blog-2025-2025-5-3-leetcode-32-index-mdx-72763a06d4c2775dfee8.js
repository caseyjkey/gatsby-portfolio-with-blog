"use strict";(self.webpackChunkportfolio_app=self.webpackChunkportfolio_app||[]).push([[5103],{5583:function(e,t,n){n.r(t),n.d(t,{BlogPost:function(){return h},default:function(){return E}});var l=n(8453),a=n(6540);function r(e){const t=Object.assign({p:"p",pre:"pre",code:"code",blockquote:"blockquote"},(0,l.R)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.p,null,"I went through a period of intense study, focusing on solving problems with C++.\r\nNow, I'm back to Python and happy to walk through this solution to\r\nlongest valid parantheses."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-python"},"class Solution:\r\n    def longestValidParentheses(self, s: str) -> int:\r\n        stack = [-1]\r\n        max_len = 0\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == '(':\r\n                stack.append(i)\r\n            else:\r\n                stack.pop()\r\n                if not stack:\r\n                    stack.append(i)\r\n                else:\r\n                    max_len = max(max_len, i - stack[-1])\r\n        \r\n        return max_len\n")),"\n",a.createElement(t.p,null,"Each time we encounter an opening paranthesis, we add its index to our stack.\r\nThus, when we find a closing parenthesis, we pop the stack.\r\nThis will leave us with the index of the last invalid index, or an empty array (we reached an invalid closing paranthesis).\r\nWith that index of the last invalid paranthesis, we calculate the max length.\r\nThis works for this  example:"),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,'Input: s = ")()"'),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"Output: 2 (correct!)"),"\n"),"\n"),"\n",a.createElement(t.p,null,"We can check with a longer example too."),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,'Input: s = ")()()"'),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"Output: 4"),"\n"),"\n"),"\n",a.createElement(t.p,null,"The time complexity is O(n) since we step through the array once,\r\nand our space complexity is also O(n).\r\nWe use a stack that can be up to N elements (all opening parantheses)."))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.R)(),e.components);return t?a.createElement(t,e,a.createElement(r,e)):r(e)},c=n(4810),s=n(4399),i=n(3614),u=n(1510),p=n(6409),m=n(572);const h=u.default.div.withConfig({displayName:"blogPostTemplate__BlogPost",componentId:"sc-6bdelx-0"})(["margin:0 auto;margin-top:6em;max-width:800px;padding:20px;"]);function d(e){let{data:t,pageContext:n,children:l}=e;const{frontmatter:r}=t.mdx,{previous:o,next:d,post:E}=n;return a.createElement(s.A,null,a.createElement(u.ThemeProvider,{theme:i.w4},a.createElement(i.nB,null,a.createElement(p.A,null),a.createElement(h,null,a.createElement(i.DZ,{className:"text-center"},r.title),a.createElement("p",{className:"text-center"},E.frontmatter.date),l,o&&a.createElement(a.Fragment,null,o&&a.createElement(c.N_,{to:o.fields.slug},a.createElement("p",null,o.frontmatter.title))),d&&a.createElement(a.Fragment,null,d&&a.createElement(c.N_,{to:d.fields.slug},a.createElement("p",null,d.frontmatter.title)))),a.createElement(m.A,null))))}function E(e){return a.createElement(d,e,a.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-template-tsx-content-file-path-posts-blog-2025-2025-5-3-leetcode-32-index-mdx-72763a06d4c2775dfee8.js.map